[{"title":"RxJava响应流程","date":"2017-07-15T13:03:28.000Z","path":"2017/07/15/RxJava响应流程/","text":"什么是响应式编程？响应式编程就是与异步数据流交互的编程范式 比较通俗的理解的话，性质和富士康里面的流水线差不多，只有当这一个步骤操作完毕之后才会进入到下个步骤。不过这里使用的是异步操作，每一个步骤可以无关其他步骤的操作结果。 Rxjava原理rxjava 工作流程就类似于两根水管之间的关系 Observable 就是上游(被观察者) 发送是事件 Observer 就是下游(观察者) 接收事件 它们之间的关系通过subscribe(订阅)产生联系 事件规则上游可以无限制的发送任意的事件，不过在规则方面有一定限制： 上游发送一个onComplete/onError事件之后，下游就不会收到onCompele/onError之后的事件了 上游可以不发送onComplete或者onNext onCompele和onError唯一且互斥 发送多个onComplete可以正常运行 发送多个onError，收到后面事件后会引起程序崩溃 Rxjava2.x相比1.x都有哪些不同 Subsriber =&gt; ObservableEmitter 事件发射器 用来发送事件,可以发出Next、Complete、Error事件 Subcription =&gt; Disposable 订阅处理器 订阅的时候通过onSubscribe方法作为参数传入，可以调用dispose()方法切断订阅关系。 切断订阅关系后，下游不会再收到事件。 Action/Func =&gt; 更改为Java8命名格式 Action1更名为Consumer，只关心onNext事件 新增Flowable =&gt; 专门应对背压问题 背压:生产者速度大于消费者速度带来的问题 ，如android 常见的点击过快造成多次点击两次的效果。 隐藏问题​ subscribe时Activity退出，回到主线程更新ui，应用崩溃。 ​ 解决：利用onSubscribe方法中传入的Disposable对象在Acitivity退出时切断订阅关系。 ​ 如果有多个Disposable，可以使用RxJava内置容器CompositeDisposable进行管理。每次得到一个Disposable就add到容器中，退出时，调用CompositeDisposable.clear()即可切断所有订阅关系。 操作符 map 转换事件，使每一个事件都按照指定的函数进行转换。 可以将事件类型转换为任意类型。 flatMap 把一个Observable转换为另一个Observable，把多个操作连贯起来。 将每一个事件单独拿出来，转换为多个事件，然后再将多个事件合并为一个Observable，最后将多个Observable发送出去。 因为faltMap做这些Observable发射的数据做的是合并操作，所以FlatMap并不保证事件的顺序 tip:map和flatMap的区别 map是在一个item被发射之后，到达map处经过转换变成另一个item，然后继续往下走。 flatMap是item被发射之后，到达flatMap处经过转换改变为一个Observable，而这个Observable并不会直接被发射出去，而是会立即激活，然后把它发射出的每个item都传入流中，再继续走下去。 所以区别有以下两个： 进过Observable的转换，想到与重新开了一个异步的流。 item被分散了，个数发生了变化。 concatMap 和flatMap作用一样，不过保证事件的发送顺序 doOnNext 允许在每次输出一个元素之前做一些额外的事情。在onNext之前调用 zip 通过一个函数将多个Observable发送的事件结合到一起，然后发送这些组合到一起的事件。 组合的顺序是严格按照事件发送顺序来进行的。 最终收到的事件数量取决于事件最少的Observable中的事件数量。 默认两个Observable在同一个线程中，所以造成一个Observable事件发送完毕后，第二个Observable才开始发送。 只要有一个Observable发送了Complete事件，两个Observable中的剩余事件都不会继续发送。 背压 当在异步线程中发送的事件数量大于接收处理的事件数量，那么其他未处理的事件就会暂时存储在内存中，数量过多后就会引起内存溢出的问题。 解决方法控制数量： ​ 使用sample()方法，在所有事件中进行取样,选择数量的事件传递到订阅者。 控制速度： ​ 每次发送事件的时候设置发送间隔。 Flowable： ​ 用Flowable替换Observable,Subscriber替换Observer Flowable​ 采用响应式拉取的方式解决上下游流速不均衡的问题。 ​ 在onSubscribe()的回调中使用request()方法，指定下游的事件处理能力。这样上游就会根据下游的处理能力发送事件。 ​ 同步代码中，如果没有调用request()方法的话，上游就认为下游没有处理事件的能力，抛出MissingBackpressureException异常。 ​ 异步代码中，如果没有调用request的话。上游会默认将事件放到一个大小为128的暂存池里面，等下游调用了request时，才会从暂存池里面取出事件，发送给下游。 处理策略 在Flowable.create(new FlowableOnSubcribe() , BackpressureStategy.Buffer)时指定 BackpressureStrategy.Error ​ 出现上下游流速不均衡的情况时，抛出MissingBackpressureException异常。默认事件的缓存大小为128 BackpressureStrategy.Buffer​ 缓存任意事件直到下游开始消耗 BackpressureStrategy.Drop ​ 把超过128之后的事件直接丢弃 BackpressureStrategy.Latest ​ 只保留最新的事件 如果不是自己创建的Flowable，可以在之后调用 onBackpressureBuffer() onBackpressureDrop() onBackPressureLatest() 指定策略模式 异步情况​ 在异步线程中一开始系统会自动调用request方法指定Io线程中的requested的值。当上游的requested的值减少到一定数量的时候，系统就会再次出发request方法，设置requested的值。 ​ 当下游每消费96个事件之后便会自动出发内部的request()方法，去设置上游的requested的值。 ​ ​","tags":[]},{"title":"DCL单例","date":"2017-07-13T15:18:40.000Z","path":"2017/07/13/DCL单例/","text":"DCL单例(Double Check Lock)123456789101112131415161718public class Singleton &#123; /** * 单例对象实例 */ private volatile static Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 使用场景 保证同一变量在多线程内存空间里面值的一致性 使用原因 在java中所有的变量都存储在主内存中，在线程工作内存中则只保存了此线程使用到的变量的副本。 而单一线程工作内存在线程之间是隔离的，其他线程不可见。 并且线程对变量的所有操作都必须在工作内存中进行，修改后的变量副本要写入主内存中。 这样就会出现同一个变量在某瞬间，在不同线程工作内存中的值可能相互不一致的情况。 实现原理 一个变量声明为volatile，就意味着变量被修改的时候其他所有使用到该变量的线程都能立即看到变化(即称为可见性)。 具体是在每次使用前都要刷新，以保证别的线程中修改的值已经反应到本线程的工作内存中。 因此可以保证执行时的一致性。 问题 JDK1.5之前不能完全避免重排序问题 解决：将变量设置成final，这样在java5中就能够正确运行了。在java5中，final变量一旦在构造函数中设置完成，其它线程必定会看到在构造函数中设置的值。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Retrofit实现原理","date":"2017-07-13T15:18:40.000Z","path":"2017/07/13/Retrofit 实现原理/","text":"Retrofit如何进行网络请求？ 主要是用到了动态代理的方式 何为动态代理？​ 当你想要调用某个类的方法前，插入你想要执行的代码。 ​ 比如你要执行某个操作前，你必须要判断这个用户是否登录，或者你在付款前，你需要判断这个人的账户中存在这么多钱。 Retrofit的动态代理在何处创建？​ 在我们非常熟悉的入口retrofit.create(XXX.class)中，返回的就是一个动态代理对象。 ​ 动态代理对象其实并不是我们请求接口的实现对象，当我们调用请求接口时候其实调用的是代理对象的动态代理方法。 具体分析当我们调用create方法的同时其实就是在生成请求接口的动态代理方法了。 首先大致的了解一下这个方法中都做了什么： 咳咳 敲黑板，划重点啦 1ServiceMethod serviceMethod = loadServiceMethod(method); 这一句是转换的具体实现了，通过建造者模式将方法中的参数进行封装 1234567891011ServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result; &#125; 解析注解信息并赋值给Builder中的成员变量 12345678910111213141516private void parseMethodAnnotation(Annotation annotation) &#123; if (annotation instanceof DELETE) &#123; parseHttpMethodAndPath(\"DELETE\", ((DELETE) annotation).value(), false); &#125; ..... isFormEncoded = true; &#125; &#125; private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123; this.httpMethod = httpMethod; this.hasBody = hasBody; .... this.relativeUrl = value; this.relativeUrlParamNames = parsePathParameters(value); &#125; 最后将Builder中的参数初始化到ServiceMethod实例中 1234567891011121314ServiceMethod(Builder&lt;R, T&gt; builder) &#123; this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; this.httpMethod = builder.httpMethod; this.relativeUrl = builder.relativeUrl; this.headers = builder.headers; this.contentType = builder.contentType; this.hasBody = builder.hasBody; this.isFormEncoded = builder.isFormEncoded; this.isMultipart = builder.isMultipart; this.parameterHandlers = builder.parameterHandlers; &#125; 现在我们的参数已经封装完毕了，下一步就是初始化请求体了 1OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); OkHttpCall中有两个方法，一个是异步执行请求enqueue，一个是同步执行请求excute，不过这两个方法的具体实现过程通过创建okhttp3.Call 来完成的。 12345678private okhttp3.Call createRawCall() throws IOException &#123; Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException(\"Call.Factory returned null.\"); &#125; return call; &#125; 这里的callFactory也是可以自定义的，默认是okHttpClient 可以通过Retrofit.Buider().client(xxxClient)来进行设置 接下来在请求完成之后会调用解析响应体的方法 123456789101112131415161718192021222324252627Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; catchingBody.throwIfCaught(); throw e; &#125; &#125; 然后是 123T toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body); &#125; 这里的converterFactory默认使用的是GsonConverterFactory，如果想要自定义的话可以通Retrofit.Buidler().addConverterFactory(JacksonConverterFactory.create()).build()方法来进行指定转换器 接下来就是真正开始执行请求了 1serviceMethod.callAdapter.adapt(okHttpCall) 这里的callAdapter也是可以通过Retrofit.Builder() .addCallAdapterFactory(RxJavaCallAdapterFactory.create()).build()来进行指定的，比较推荐的是现在流行的RxJavaCallAdapterFaactory 如果没有指定的话，Retrofit中有设置的默认处理器工厂，这个就是ExecutorCallAdapterFactory 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(\"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //post一个任务到主线程 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; .... &#125;&#125; 这样整个流程就差不多了，等到调用成功之后就可以接收到解析后的响应数据了","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"动态代理机制","date":"2017-07-13T15:18:40.000Z","path":"2017/07/13/动态代理机制/","text":"动态代理 动态代理的优点有： 隐藏委托类的实现 解耦，不改变委托类代码情况下做一些额外处理 方便对代理类的函数做统一或特殊处理 实现步骤 新建接口类 1234public interface Subject &#123; public void doSomething(); &#125; 创建委托类并实现定义的接口类 1234567public class RealSubject implements Subject &#123; public void doSomething() &#123; System.out.println( \"call doSomething()\" ); &#125; &#125; 创建代理帮助类，实现InvocationHandler接口 InvocationHandler:是负责连接代理类和委托类的中间类必须实现的接口 12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class ProxyHandler implements InvocationHandler&#123; private Object tar; //绑定委托对象，并返回代理类 public Object bind(Object tar) &#123; //tar属性表示委托类对象。 this.tar = tar; //绑定该类实现的所有接口，取得代理类 return Proxy.newProxyInstance( //loader表示类加载器 tar.getClass().getClassLoader(), //interfaces表示委托类的接口，生成代理类时需要实现这些接口 tar.getClass().getInterfaces(), //InvocationHandler实现类对象，负责连接代理类和委托类的中间类 this); &#125; //当proxy生成字节码时 会调用invoke方法 public Object invoke(Object proxy , Method method , Object[] args)throws Throwable &#123; Object result = null; //这里就可以进行所谓的AOP编程了 //在调用具体函数方法前，执行功能处理 result = method.invoke(tar,args); //在调用具体函数方法后，执行功能处理 return result; &#125;&#125; 1234567891011public class TestProxy&#123; public static void main(String args[]) &#123; ProxyHandler proxy = new ProxyHandler(); //绑定该类实现的所有接口 Subject sub = (Subject) proxy.bind(new RealSubject()); //调用代理对象的每个函数实际最终都是调用了InvocationHandler的invoke函数。 sub.doSomething(); &#125;&#125; 原理 动态代理可以理解为双向静态代理，我们先是创建委托类B，系统动态生成代理类A。 然后创建一个实现了InvocationHandler的子类C，子类连接代理类A和委托类B。 它是代理类A的委托类，是委托类B的代理类。 用户直接调用代理类A的对象，A将调用转给它的委托类C，委托类C再将调用转发给它的委托类B。 用到的地方 jfinal框架中的拦截器机制就是基于动态代理实现的。 使用 cglib 动态代理 将InvocationHandler抽象为一个Invocation，在invoke方法中实现调用委托类方法之前对本次请求进行拦截。 Retrofit:简化了网络请求 ####","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"桎梏","date":"2017-05-07T08:21:34.000Z","path":"2017/05/07/桎梏/","text":"我们宁愿告诉自己“外出是为了更加美好的生活品质”，而不是“我是因为自己一个人并且无所事事”。活在幻想里是一个比较轻松的选项，唯有这样，才让我们的行为有了意义。 “群居“这个属性在我们的祖先还是类人猿的时候就已经早早存在，因为那时候的人类无比弱小。处于巨型食肉动物的夹缝当中，不待在一起就是死路一条。一直到现在还是这个基因序列还是没有发生变化，尽管我们已经远离了风饕雪虐的原始社会，但是在独居的时候还是会有那种失落感。 这种感觉可以克服吗? 谁也说不准，就好像我们不能里对于甜食的喜爱也是因为我们祖先很久吃不到一次甜食而深深留下的痕迹。","tags":[]},{"title":"在路上","date":"2017-05-07T06:23:23.000Z","path":"2017/05/07/在路上/","text":"在路上虽有万千思绪，可腹中无墨，又何以能记。 括苍山 人都有一颗向外的心。 居于一隅，度日往复。 又怎么能够平静。 在五一还没到来的前一周就开始筹划着假期的行程，按捺不住的心开始骚动。可能是大学的时候憋久了吧，自从毕业之后就开始东奔西跑，导致现在也有了这个习惯。 运气不错，在临出发之前找到了小伙伴一同前往。果然年轻人之前的隔阂就是一层挥之即去的薄纱，此去之行相聊甚欢。 中国的优势在此刻展示的无与伦比，路上车流不息。把三个小时的车程硬生生延长了一倍。这次行程是自由行，所以偷懒直接把车开到了山顶。不过到了上山的时候，又是一番惊险。转身之后就是深渊，可偏偏狭路之前总是几多相逢。 连绵的山，矗立着很多风力发电机。绿色和白色相互映衬，柔和而舒服。 人工的痕迹在这里彻底的融入了进入，不突兀，不放纵。 续安卓几个月的后台开发就像历险一样，处在不同的身份才能感受到不同的差异。当生产者和消费者的身份改变之后，就不能只按照自己的固有思维去解决问题了。一切的东西都要想的到，每一个方法的编写，每一个字段的命名都不只是关乎于自己。 虽然说后台开发暂时告一段落了，但是思想还是需要保持。 每天都来点小挑战，这样才能过的足够精彩。","tags":[]},{"title":"java笔记","date":"2017-05-02T02:26:02.000Z","path":"2017/05/02/java笔记/","text":"1.HashMap和HashTable的区别 HashMap去掉了contains方法 HashTable是同步的(线程安全) HashMap允许空键值 HashMap执行快速失败机制 Fast-fail机制:在使用迭代器的过程中有其它线程修改了集合对象结构或元素数量,都将抛出ConcurrentModifiedException HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。 Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。 2.java的线程安全类Vector、Stack、HashTable、ConcurrentHashMap、Properties 3.java集合框架123456789Collection - List - ArrayListCollection - List - LinkedListCollection - List - VectorCollection - List - Vector - StackCollection - Set - HashSetCollection - Set - TreeSetMap - HashMapMap - TreeMapMap - HashTable 3.1 ArrayList的构造函数有三个 无参构造 容量为10 ArrayList(Collections&lt;?extends E&gt; c)构造包含指定collection的元素的列表 ArrayList(int initialCapacity) 指定初始容量 3.2 Iterator(迭代器)支持从源集合安全地删除对象,防止并发修改异常(ConcurrentModifiedException) 4.Java垃圾回收机制4.1 调用system.gc() Runtime.getRuntime.gc() 4.2 垃圾回收:释放那些不再持有任何引用的对象的内存 4.3 怎样判断是否需要收集： 引用计数法：对象没有任何引用与之关联(无法解决循环引用) 对象引用遍历法：对象引用遍历从一组对象开始,沿着对象图的每条链接,递归确定可以到达的对象,如果某对象不能从这些根对象的一个(至少一个)到达,则将它作为垃圾收集。 4.4 垃圾回收方法 标记清除法(Mark-Sweeping):易产生内存碎片 复制回收法(Copying)：为了解决Mark-Sweep法而提出,内存空间减至一半 标记压缩法(Mark-Compact):为了解决Copying法的缺陷,标记后移动到一端再清楚 分代回收法(GenerationalCollection):新生代对象存活周期短,需要大量回收对象,需要复制的少,执行copying算法;老年代对象存活周期相对长,回收少量对象,执行mark-compact算法.新生代划分：较大的eden区 和 2个survivor区 简单来讲，jvm的内存回收过程是这样的： 对象在Eden Space创建，当Eden Space满了的时候，gc就把所有在Eden Space中的对象扫描一次，把所有有效的对象复制到第一个Survivor Space，同时把无效的对象所占用的空间释放。 当Eden Space再次变满了的时候，就启动移动程序把Eden Space中有效的对象复制到第二个Survivor Space，同时，也将第一个Survivor Space中的有效对象复制到第二个Survivor Space。 如果填充到第二个Survivor Space中的有效对象被第一个Survivor Space或Eden Space中的对象引用，那么这些对象就是长期存在的，此时这些对象将被复制到Permanent Generation。 若垃圾收集器依据这种小幅度的调整收集不能腾出足够的空间，就会运行Full GC，此时jvm gc停止所有在堆中运行的线程并执行清除动作。 4.5 内存分配 新生代 |Eden Space|From Space|To Space| 对象主要分配在新生代的EdenSpace和FromSpace 如果EdenSapce和FromSpace空间不足,则发起一次GC 若进行GC后,EdenSpace和FromSpace能够容纳该对象,就放在Eden和FromSpace。在GC过程中会将EdenSpace和FromSpace存活的对象移动到ToSpace,然后清理Eden和From。若在清理过程中,ToSpace无法足够容纳该对象,则将该对象移入老年代中。在进行GC后,Eden和From为空,MinorGC完成。From和To标记互换。To区(逻辑上)始终为空。 新生代的回收成为MinorGC,对老年代的回收成为MajorGC又名FullGC其他 优先在Eden上分配 大对象直接进入老年代 长期存活的对象进入老年代 动态对象年龄判定 suvivor区同年龄对象总和大于suvivor区空间的一半,MinorGC时复制至老年代 空间分配担保 新生代放不下借用老年代,虚拟机检测GC租借的老年代内存是否大于剩余的老年代内存。若大于,MinorGC变为一次FullGC。若小于,查看虚拟机是否允许担保失败,若允许则执行一次MinorGC,否则也要变为一次FullGC HotSpot虚拟机GC算法采用分代收集算法： 1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。 2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。 3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。 5.一些重要的关键字 volatileJava 语言提供了一种稍弱的同步机制,即volatile变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新。 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的。volatile修饰变量,每次被线程访问时强迫其从主内存重读该值,修改后再写回共享内存。保证读取的可见性,对其他线程立即可见。由于不保证原子性,也就不能保证线程安全。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况。同时,volatile屏蔽了VM中必要的代码优化,效率上较低。另一个优点：禁止指令重排序 finalfinal修饰的变量是常量，必须进行初始化，可以显示初始化，也可以通过构造进行初始化，如果不初始化编译会报错。 6.多线程 &amp; 并发 &amp; 同步 &amp; 锁6.1 线程的run方法和start方法 start方法https://github.com/qinjx/30min_guides用start方法来启动线程,是真正实现了多线程。调用thread类的start方法来启动一个线程,此时线程处于就绪状态,一旦得到cpu时间片,就开始执行run方法。注：此时无需等待run方法执行完毕,即可执行下面的代码,所以run方法并没有实现多线程。 run方法只是thread类的一个普通方法,若直接调用程序中依然只有主线程这一个线程,还要顺序执行,依然要等待run方法体执行完毕才可执行下面的代码。 6.2 ReadWriteLock(读写锁) 写写互斥 读写互斥 读读并发在读多写少的情况下可以提高效率 6.3 resume(继续挂起的线程)和suspend(挂起线程)一起用 6.4 wait与notify、notifyall一起用 6.5 sleep与wait的异同点 sleep是Thread类的静态方法,wait来自object类 sleep不释放锁,wait释放锁 wait,notify,notifyall必须在同步代码块中使用,sleep可以在任何地方使用 都可以抛出InterruptedException 6.6 让一个线程停止执行 异常 - 停止执行休眠 - 停止执行阻塞 - 停止执行 6.7 ThreadLocal相关 ThreadLocal解决了变量并发访问的冲突问题 当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类) 与synchronized同步机制的比较 首先,它们都是为了解决多线程中相同变量访问冲突问题。不过,在同步机制中,要通过对象的锁机制保证同一时间只有一个线程访问该变量。该变量是线程共享的,使用同步机制要求程序缜密地分析什么时候对该变量读写,什么时候需要锁定某个对象,什么时候释放对象锁等复杂的问题,程序设计编写难度较大,是一种“以时间换空间”的方式。而ThreadLocal采用了以“以空间换时间”的方式。 7.接口与抽象类 一个子类只能继承一个抽象类,但能实现多个接口 抽象类可以有构造方法,接口没有构造方法 抽象类可以有普通成员变量,接口没有普通成员变量 抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认) 抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法 抽象类可以有静态方法，接口不能有静态方法 抽象类中的方法可以是public、protected和默认;接口方法只有public 8.Statement接口8.1 Statement是最基本的用法，不传参，采用字符串拼接，存在注入漏洞 PreparedStatement传入参数化的sql语句,同时检查合法性，效率高，可以重用,防止sql注入 CallableStatement接口扩展PreparedStatement，用来调用存储过程 public interface CallableStatement extends PreparedStatement public interface PreparedStatement extends Statement BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类 8.2 Statement与PrepareStatement的区别 创建时的区别 12Statement statement = conn.createStatement();PreparedStatement preStatement = conn.prepareStatement(sql); 执行的时候 12ResultSet rSet = statement.executeQuery(sql);ResultSet pSet = preStatement.executeQuery(); 由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，而 statement 不同，如果执行多遍，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些 安全性 preStatement是预编译的，所以可以有效的防止SQL注入等问题 代码的可读性和可维护性 PreparedStatement更胜一筹 9.抽象类和最终类抽象类可以没有抽象方法,最终类可以,没有最终方法 最终类不能被继承,最终方法不能被重写(可以重载) 10.异常10.1 throw、throws、try…catch、finally throws用在方法上,方法内部通过throw抛出异常 try用于检测包住的语句块,若有异常,抛出并执行catch子句 catch捕获try块中抛出的异常并处理 10.2 关于finally finally不管有没有异常都要处理 finally{}比return先执行,多个return执行一个后就不在执行 不管有木有异常抛出,finally在return返回前执行 10.3 受检查异常和运行时异常 粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… 而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 11.this &amp; super11.1 super出现在父类的子类中。有三种存在方式 super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用 super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法 super() 调用父类构造 super只能指代其直接父类 11.2 this() &amp; super()在构造方法中的区别 调用super()必须写在子类构造方法的第一行,否则编译不通过 super从子类调用父类构造,this在同一类中调用其他构造 均需要放在第一行 尽管可以用this调用一个构造器,却不能调用2个 this和super不能出现在同一个构造器中,否则编译不通过 this()、super()都指的对象,不可以在static环境中使用 本质this指向本对象的指针。super是一个关键字 12.修饰符一览12345修饰符 类内部 同一个包 子类 任何地方private yesdefault yes yesprotected yes yes yespublic yes yes yes yes 13.构造内部类对象1234567891011public class Enclosingone &#123; public class Insideone &#123;&#125; public static class Insideone&#123;&#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Enclosingone.Insideone obj1 = new Enclosingone().new Insideone(); Enclosingone.Insideone obj2 = new Enclosingone.Insideone(); &#125;&#125; 14.序列化声明为static和transient类型的数据不能被序列化,序列化的笔记参见Java-note-序列化.md 15.Java的方法区与堆一样,是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。 16.正则表达式次数符号 12345* 0或多次+ 1或多次？0或1次&#123;n&#125; 恰n次&#123;n,m&#125; 从n到m次 其他符号 符号 等价形式 1234567\\d [0-9]\\D [^0-9] \\w [a-zA-Z_0-9]\\W [^a-zA-Z_0-9]\\s [\\t\\n\\r\\f]\\S [^\\t\\n\\r\\f]. 任何字符 边界匹配器 行开头 ^行结尾 $单词边界 \\b 贪婪模式:最大长度匹配 非贪婪模式:匹配到结果就好,最短匹配 环视 1234567891011121314字符 描述 匹配对象. 单个任意字符 [...] 字符组 列出的任意字符[^...] 未列出的任意字符^ caret 行的起始位置$ dollar 行的结束位置\\&lt; 单词的起始位置\\&gt; 单词的结束位置\\b 单词边界\\B 非单词边界(?=Expression) 顺序肯定环视 成功,如果右边能够匹配(?!Expression) 顺序否定环视 成功,如果右边不能够匹配(?&lt;=Expression) 逆序肯定环视 成功,如果左边能够匹配(?&lt;!Expression) 逆序否定环视 成功,如果左边不能够匹配 举例:北京市(海定区)(朝阳区)(西城区) Regex: .*(?=\\() 模式和匹配器的典型调用次序 把正则表达式编译到模式中Pattern p = Pattern.compile(“a*b”); 创建给定输入与此模式的匹配器Matcher m = p.matcher(“aaab”); 尝试将整个区域与此模式匹配boolean b = m.matches(); 17.Servlet &amp; JSP &amp; Tomcat17.1 Servlet继承实现结构 1234Servlet (接口) --&gt; init|service|destroy方法GenericServlet(抽象类) --&gt; 与协议无关的ServletHttpServlet(抽象类) --&gt; 实现了http协议自定义Servlet --&gt; 重写doGet/doPost 17.2 编写Servlet的步骤 继承HttpServlet 重写doGet/doPost方法 在web.xml中注册servlet 17.3 Servlet生命周期 init:仅执行一次,负责装载servlet时初始化servlet对象 service:核心方法,一般get/post两种方式 destroy:停止并卸载servlet,释放资源 17.4 过程 客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若存在调用相应service方法 客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若不存在装载Servlet类并创建实例 -&gt; 调用init初始化 -&gt; 调用service 加载和实例化、初始化、处理请求、服务结束 17.5 doPost方法要抛出的异常:ServletExcception、IOException 17.6 Servlet容器装载Servlet web.xml中配置load-on-startup启动时装载 客户首次向Servlet发送请求 Servlet类文件被更新后,重新装载Servlet 17.7 HttpServlet容器响应web客户请求流程 Web客户向servlet容器发出http请求 servlet容器解析Web客户的http请求 servlet容器创建一个HttpRequest对象,封装http请求信息 servlet容器创建一个HttpResponse对象 servlet容器调用HttpServlet的service方法,把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象 HttpServlet调用httprequest的有关方法,获取http请求信息 httpservlet调用httpresponse的有关方法,生成响应数据 Servlet容器把HttpServlet的响应结果传给web客户 17.8 HttpServletRequest完成的功能 request.getCookie() request.getHeader(String s) request.getContextPath() 17.9 HttpServletResponse完成的功能 设http头 设置Cookie 输出返回数据 17.10 session 12HttpSession session = request.getSession(boolean create)返回当前请求的会话 17.11 JSP的前身就是Servlet 17.12 Tomcat容器的等级 Tomcat - Container - Engine - Host - Servlet - 多个Context(一个Context对应一个web工程)-Wrapper 17.13 Servlet与JSP九大内置对象的关系 JSP对象 怎样获得 1234567891. out -&gt; response.getWriter2. request -&gt; Service方法中的req参数3. response -&gt; Service方法中的resp参数4. session -&gt; request.getSession5. application -&gt; getServletContext6. exception -&gt; Throwable7. page -&gt; this8. pageContext -&gt; PageContext9. Config -&gt; getServletConfig exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。 18.struts struts可进行文件上传 struts基于MVC模式 struts让流程结构更清晰 struts有许多action类,会增加类文件数目 19.Hibernate的7大鼓励措施 尽量使用many-to-one,避免使用单项one-to-many 灵活使用单项one-to-many 不用一对一,使用多对一代替一对一 配置对象缓存,不使用集合对象 一对多使用bag,多对一使用set 继承使用显示多态 消除大表,使用二级缓存 20.JVM20.1 JVM内存配置参数 -Xmx:最大堆大小 -Xms:初始堆大小(最小内存值) -Xmn:年轻代大小 -XXSurvivorRatio:3 意思是Eden:Survivor=3:2 -Xss栈容量 -XX:+PrintGC 输出GC日志 -XX:+PrintGCDetails 输出GC的详细日志 20.2 JVM内存结构 堆:Eden、Survivor、old 线程共享 方法区(非堆):持久代,代码缓存,线程共享 JVM栈:中间结果,局部变量,线程隔离 本地栈:本地方法(非Java代码) 程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址 注：持久代Java8消失,取代的称为元空间(本地堆内存的一部分) 21.面向对象的五大基本原则(solid) S单一职责SRP:Single-Responsibility Principle一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。 O开放封闭原则OCP:Open-Closed Principle软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭 L里氏替换原则LSP:Liskov-Substitution Principle子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。 I接口隔离原则ISP:Interface-Segregation Principle使用多个小的接口,而不是一个大的总接口 D依赖倒置原则DIP:Dependency-Inversion Principle依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。 面向对象设计原则 封装变化 少用继承 多用组合 针对接口编程 不针对实现编程 为交互对象之间的松耦合设计而努力 类应该对扩展开发 对修改封闭（开闭OCP原则） 依赖抽象，不要依赖于具体类（依赖倒置DIP原则） 密友原则：只和朋友交谈（最少知识原则） 说明：将方法调用保持在界限内，只调用属于以下范围的方法：该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象 别找我（调用我） 我会找你（调用你）（好莱坞原则） 一个类只有一个引起它变化的原因（单一职责SRP原则） 22.null可以被强制转型为任意类型的对象。23.代码执行次序 多个静态成员变量,静态代码块按顺序执行 单个类中: 静态代码 -&gt; main方法 -&gt; 构造块 -&gt; 构造方法 构造块在每一次创建对象时执行 涉及父类和子类的初始化过程a.初始化父类中的静态成员变量和静态代码块 b.初始化子类中的静态成员变量和静态代码块 c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法(注意父类构造方法中的子类方法覆盖) d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法 24.红黑树二叉搜索树:(Binary Search Tree又名：二叉查找树,二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： 若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。 红黑树的定义:满足以下五个性质的二叉搜索树 每个结点或是红色的或是黑色的 根结点是黑色的 每个叶结点是黑色的 如果一个结点是红色的,则它的两个子结点是黑色的 对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点 黑高 从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。红黑树的黑高为其根结点的黑高。 其他 一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1) 结点的属性(五元组):color key left right p 动态集合操作最坏时间复杂度为O(lgn) 25.排序 稳定排序:插入排序、冒泡排序、归并排序、基数排序 插入排序[稳定]适用于小数组,数组已排好序或接近于排好序速度将会非常快复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 归并排序[稳定]采用分治法复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(n)[平均 - 最好 - 最坏 - 空间复杂度] 冒泡排序[稳定]复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 基数排序 分配+收集[稳定]复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r) 树排序应用：TreeSet的add方法、TreeMap的put方法不支持相同元素,没有稳定性问题复杂度：平均最差O(nlogn) 堆排序(就地排序)复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 快速排序复杂度：O(nlgn) - O(nlgn) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]栈空间0(lgn) - O(n) 选择排序复杂度：O(n^2) - O(n^2) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 希尔排序复杂度 小于O(n^2) 平均 O(nlgn) 最差O(n^s)[1&lt;s&lt;2] 空间O(1) 26.查找与散列26.1 散列函数设计 直接定址法:= a*key+b```1234简单、均匀,不易产生冲突。但需事先知道关键字的分布情况,适合查找表较小且连续的情况,故现实中并不常用- 除留余数法:```f(key) = key mod p (p&lt;=m) p取小于表长的最大质数 m为表长 DJBX33A算法(time33哈希算法hash = hash*33+(unsigned int)str[i]; 平方取中法 折叠法 更多…. 26.2 冲突处理 闭散列(开放地址方法):要求装填因子a较小，闭散列方法把所有记录直接存储在散列表中 线性探测:易产生堆积现象(基地址不同堆积在一起) 二次探测:f(key) = (f(key)+di) % m di=1^2,-1^2,2^2,-2^2…可以消除基本聚集 随机探测:f(key) = (f(key)+di),di采用随机函数得到,可以消除基本聚集 双散列:避免二次聚集 开散列(链地址法):原地处理 同义词记录存储在一个单链表中,散列表中子存储单链表的头指针。 优点:无堆积 事先无需确定表长 删除结点易于实现 装载因子a&gt;=1,缺点:需要额外空间 27.枚举类JDK1.5出现 每个枚举值都需要调用一次构造函数 28.数组复制方法 for逐一复制 System.arraycopy() -&gt; 效率最高native方法 Arrays.arrayOf() -&gt; 本质调用arraycopy clone方法 -&gt; 返回Object[],需要强制类型转换 29.多态 Java通过方法重写和方法重载实现多态 方法重写是指子类重写了父类的同名方法 方法重载是指在同一个类中，方法的名字相同，但是参数列表不同 30.Java文件.java文件可以包含多个类，唯一的限制就是：一个文件中只能有一个public类， 并且此public类必须与文件名相同。而且这些类和写在多个文件中没有区别。 31.Java移位运算符java中有三种移位运算符 &lt;&lt; :左移运算符,x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0 :带符号右移,x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1 :无符号右移,忽略符号位,空位都以0补齐 32.形参&amp;实参 形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。 33.IO 34.局部变量为什么要初始化局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。 35.JDK提供的用于并发编程的同步器 Semaphore Java并发库的Semaphore可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 CyclicBarrier 主要的方法就是一个：await()。await()方法每被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此CyclicBarrier上面阻塞的线程开始运行。 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 36.Java类加载器一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： Bootstrap ClassLoader(引导类加载器) 负责加载java基础类，主要是 %JRE_HOME/lib/目录下的rt.jar、resources.jar、charsets.jar等 Extension ClassLoader(扩展类加载器) 负责加载java扩展类，主要是 %JRE_HOME/lib/ext目录下的jar等 App ClassLoader(系统类加载器) 负责加载当前java应用的classpath中的所有类。classloader 加载类用的是全盘负责委托机制。 所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。所以，当我们自定义的classloader加载成功了com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。 37.Java语言的鲁棒性Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。 38.Java语言特性 Java致力于检查程序在编译和运行时的错误 Java虚拟机实现了跨平台接口 类型检查帮助检查出许多开发早期出现的错误 Java自己操纵内存减少了内存出错的可能性 Java还实现了真数组，避免了覆盖数据的可能 39.Hibernate延迟加载 Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） Hibernate3 提供了属性的延迟加载功能当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。42.Java语法糖 Java7的switch用字符串 - hashcode方法 switch用于enum枚举 伪泛型 - List原始类型 自动装箱拆箱 - Integer.valueOf和Integer.intValue foreach遍历 - Iterator迭代器实现 条件编译 enum枚举类、内部类 可变参数 - 数组 断言语言 try语句中定义和关闭资源 43.JVM工具命令行 jps(jvm processor status)虚拟机进程状况工具 jstat(jvm statistics monitoring)统计信息监视 jinfo(configuration info for java)配置信息工具 jmap(memory map for java)Java内存映射工具 jhat(JVM Heap Analysis Tool)虚拟机堆转储快照分析工具 jstack(Stack Trace for Java)Java堆栈跟踪工具 HSDIS：JIT生成代码反汇编 可视化 JConsole(Java Monitoring and Management Console):Java监视与管理控制台 VisualVM(All-in-one Java Troubleshooting Tool):多合一故障处理工具","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Docker 实践笔记","date":"2017-04-28T07:40:27.000Z","path":"2017/04/28/Docker-实践笔记/","text":"了解Docker 一句话介绍： ​ docker是一个用来装应用的容器 What is Docker ? ​ Docker is the world’s leading software container platform. ​ 世界领先的软件容器化平台。a Docker 思想 集装箱 标准化 运输方式 存储方式 API接口 隔离 Docker解决了什么问题？ 运行环境不一致带来的问题。 隔离运行，防止程序受别人程序影响。 让快速扩展，弹性伸缩变得简单。 走进DockerDocker的核心技术 运行过程： ​ 去仓库把镜像下载到本地，然后用命令吧镜像运行起来，变成容器。 镜像 —&gt;集装箱—&gt;Build 仓库—&gt;超级码头—&gt;Ship 容器—&gt;运行程序的地方—&gt;Run Docker镜像 多个文件的集合 格式： 联合文件系统： 可以将不同的目录挂载到同一个文件系统下。 即：可以在同一个目录下可以看到多个文件夹的集合 docker镜像就是利用这种分层的概念，来实现的镜像存储。 Docker容器 本质就是一个进程，可以想象为一个虚拟机。 ​ 容器是可以修改的，镜像是不可修改的。 ​ 所以一个镜像可以生成多个容器，独立运行。 Docker仓库中央仓库 hub.docker.com c.163.com 安装Dockermac [下载地址](https://download.docker.com/mac/stable/Docker.dmg Linux uname -r 查看当前系统版本，必须大于3.3 su 切换至root身份 apt-get update 更新apt应用 apt-get install -y docker.io或者curl -s https://get.docker.com 输入docker version检查是否安装成功 提示 are you trying to connect to a tls-enabled daemon without tls的解决方法 输入：sudo service docker start Docker初体验第一个docker镜像 service docker start 开启docker服务 docker pull [Options] Name[:Tag] option:拉取的参数 Tag:拉取的版本，不填写默认为最新版本 docker pull hello-world docker images ‘省略左中括号’ Options][Repository[:Tag]] 第一个docker容器 docker run hello-world docker运行Nginx镜像 拉取镜像 docker pull hub.c.163.com/library/nginx:latest 运行镜像 docker run -d hub.c.163.com/library/nginx 显示运行容器 docker ps 进入容器内部 docker exec -it [Option] bash 就是进入到了一个虚拟机内部 docker网络 开启容器端口映射 docker run -p -p 开放一个端口到主机上，默认为空 -P 开放所有端口到对应的随机端口 docker run -d -p 8080:80 hub.c.163.com/library/nginx 8080:主机端口 80:容器端口 第一个javaweb项目 下载Jpress到本地 下载tomcat镜像到本地 docker pull hub.c.163.com/library/tomcat:latest 创建Dockerfile 文件 输入 123456# 继承自哪一个基础镜像 --&gt; javaweb程序肯定会用到tomcatfrom hub.c.163.com/library/tomcat# 镜像的所有者姓名和联系方式MAINTAINER haorui konghaoruis@gmail.com# 复制外部应用文件到镜像指定位置COPY jpress.war /usr/local/tomcat/webapps ​ 生成镜像文件 docker build -t jpress:latest .(注意最后有一个空格和点！) -t:镜像指定Tag 创建容器 docker run -d -p 8081:8080 jpress 下载mysql镜像 docker pull hub.c.163.com/library/mysql:latest 运行mysql镜像 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest -e：环境变量 MYSQL_ROOT_PASSWORD:数据库用户密码 MYSQL_DATABASE:数据库名","tags":[]},{"title":"Spring Boot 实践笔记","date":"2017-04-27T09:18:40.000Z","path":"2017/04/27/Spring-Boot-实践笔记/","text":"介绍 SpringBoot是SpringMVC的升级版，两者没有直接的联系。 特点 简化配置，抛掉繁琐的xml配置文件。 下一代框架，受关注度高。 微服务的入门级微框架。 微服务：当下流行的一种架构/解决方案 SpringCloud：是Spring家族为微服务提供的一整套服务 SpringCloud 基于SpringBoot开发，学习SpringCloud必须先学习SpringBoot 环境配置 java版本 java version “1.8.0_121” maven版本 Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00) IntelliJ IDEA 版本 IntelliJ IDEA 2016.3.6Build #IU-163.15188.11, built on March 25, 2017Licensed to haorui JRE: 1.8.0_112-release-408-b6 x86_64 JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o 构建项目 创建项目，选择Spring Initializr 配置项目参数 选择Spring组件 ​ pom文件结构 文件说明 SpringBootDemoApplication：项目启动类，创建项目自动生成 @SpringBootApplication：项目启动注解。项目如果要启动，必须要改注解 application.properties：SpringBoot配置文件 Hello World 创建类HelloController,添加@RestController注解。 创建方法 1234@RequestMapping(value = \"/hello\",method = RequestMethod.GET)private String say() &#123; return \"Hello Spring Boot !\";&#125; 启动项目 在浏览器地址栏输入 http://127.0.0.1:8080/hello 启动方式 在启动类右击，选择”Run SpringBootDemoApplication” maven命令启动 进入项目根目录 命令行输入命令 1mvn spring-boot:run Jar命令启动 进入项目根目录 使用mvn install 命令编译项目 进入target目录，输入命令 1java -jar spring_boot-0.0.1-SNAPSHOT.jar 项目配置默认配置文件：application.properties 参数说明： server.port=8081 # 服务端口号 server.context-path=/demo # 服务上下文 推荐配置文件格式：YAML YAML 是专门用来写配置文件的语言，非常简洁和强大 基本语法 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 数据结构 对象：键值对的集合 数组：一组按次序排列的值 纯量：单个的、不可再分的值 创建文件：applicaion.yml 参数说明 123server: port: 8081 #服务端口号 context-path: /demo #服务上下文 使用 定义 无需关注定义类型 1name: jack 获取配置参数 根据类型不同，设置不同属性。 12@Value(\"$&#123;name&#125;\")private String name; 在配置文件中使用当前配置 123name: jackage: 18content: \"name:$&#123;name&#125;,age:$&#123;age&#125;\" 将配置文件分组映射为一个类 定义yaml分组属性 123person: name: jack age: 18 创建类：PersonProperties 添加注解到类上，前缀为yaml文件中定义的分组属性 12@Component//注入配置@ConfigurationProperties(prefix = \"person\")//配置属性 创建get/set方法(Idea快捷键:commond+n) 使用映射类 12@Autowiredprivate PersonProperties personProperties; 启动时使用不同的配置文件 创建开发配置 复制application.yml，更名为application-dev.yml 创建生产配置 复制application.yml，更名为application-prod.yml 更改使用的配置文件 在application.yml中指定配置文件 123spring: profiles: active: dev 使用不同的配置文件启动项目 使用java -jar 的方式指定配置文件 1java -jar --spring.profiles.active=prod Controller使用 @Controller :处理http请求 @RestController:处理请求并声明返回数据 等同于@Controller+@ResponseBody @RequestMapping:配置url映射 1@RequestMapping(value = \"/hello\",method = RequestMethod.GET) value ：url映射地址。可以为数组,格式为 1value = &#123;\"/hello\",\"/hi\"&#125; method：定义请求方式 不指定条件下，任何类型的请求都可以成功 @PathVariable:获取url中的数据 1234567//请求地址：127.0.0.1:8080/hello/100//参数字段可以放在url前面 如：/&#123;id&#125;/hello@RequestMapping(value = \"/hello/&#123;id&#125;\", method = RequestMethod.GET)private String say(@PathVariable(\"id\") Integer id) &#123; return \"Id:\" + id;&#125; @RequestParam：获取请求参数的值 参数 value:参数名 required：是否必填 defaultValue：默认值，必须是字符 示例 1234567//请求地址：127.0.0.1:8080/hello?id=100//使用传统方式传递数据@RequestMapping(value = \"/hello\", method = RequestMethod.GET)private String say(@RequestParam(\"id\", required = false, defaultValue = \"0\") Integer id) &#123; return \"Id:\" + id;&#125; @GetMapping：组合注解 等同于@RequestMapping + method = RequestMethod.GET @PostMapping:组合注解 等同于@RequestMapping + method = RequestMethod.POST 数据库操作 使用Spring-Data-Jpa组件进行数据库操作 JPA：定义了一系列对象持久化的标准。 添加组件123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 配置组件 在application.yml 文件中添加配置 1234567891011121314151617181920spring: profiles: active: dev# mysql配置 datasource: driver-class-name: com.mysql.jdbc.Driver #数据库驱动 url: jdbc:mysql://127.0.0.1:3306/dbperson #数据库地址 username: root #用户名 password: #密码# jpa配置 jpa: hibernate: ddl-auto: update # create :每次程序运行的时候会先创建一个空的表，如果表已存在的话，会先删掉 # update :第一次运行的时候也会创建表结构，不过如果表中有数据的话，不会删掉 # create-drop :应用停下来就会将表给删掉 # none :什么也不做 # validate :会验证表结构是否一致，不一致会报错 show-sql: true # 是否显示log 创建数据库 进入mysql 执行 create database dbperson 增删改查 创建数据库对应类：Person 123456789101112131415@Entity //表示对应数据库中的一个表public class Person &#123; @Id @GeneratedValue //主键自增长 private Integer id; private String name; private Integer age; /** * 必须选择一个无参构造方法 * 否则数据库会报错 */ public Person() &#123; &#125; public void get/set 略....&#125; ​ 创建数据库操作类 12345678910//创建一个接口，继承jpa，泛型填入类名和id的类型public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt; &#123; /** * 通过年龄查询人员 * 方法名必须是findByXXX * @param age * @return */ public List&lt;Person&gt; findByAge(Integer age);&#125; 创建Person控制器，操作数据库进行增删改查操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@RestControllerpublic class PersonController &#123; @Autowired private PersonRepository personRepository; /** * 查询所有人员列表 * * @return */ @GetMapping(value = \"/persons\") public List&lt;Person&gt; getList() &#123; return personRepository.findAll(); &#125; /** * 添加人员 * * @param age * @param name * @return */ @PostMapping(value = \"/addPerson\") public Person addPerson(@RequestParam(\"age\") Integer age, @RequestParam(\"name\") String name ) &#123; //创建对象，保存到数据库 Person person = new Person(); person.setAge(age); person.setName(name); return personRepository.save(person); &#125; /** * 查询一个人员 * * @param id * @return 查无，返回200，空 */ @GetMapping(value = \"/persons/&#123;id&#125;\") public Person getPerson(@PathVariable(\"id\") Integer id) &#123; return personRepository.findOne(id); &#125; /** * 更新一个人员 * * @param id * @param age * @param name * @return */ @PutMapping(value = \"/persons/&#123;id&#125;\") public Person updatePerson(@PathVariable(\"id\") Integer id, @RequestParam(\"age\") Integer age, @RequestParam(\"name\") String name ) &#123; Person person = new Person(); person.setId(id); person.setAge(age); person.setName(name); return personRepository.save(person); &#125; /** * 删除一个人员 * * @param id */ @DeleteMapping(value = \"/persons/&#123;id&#125;\") public void delPerson(@PathVariable(\"id\") Integer id) &#123; personRepository.delete(id); &#125; /** * 根据年龄查询人员 * * @param age * @return */ @GetMapping(value = \"/persons/age/$&#123;age&#125;\") public List&lt;Person&gt; getPersons(@PathVariable(\"age\") Integer age) &#123; return personRepository.findByAge(age); &#125;&#125; 事务管理 操作多条数据，最终结果执行失败。操作过程不会保存。 建议除了查询语句外，其他方法都最好加上事务注解。 123456789101112131415161718192021222324@Servicepublic class PersonService &#123; @Autowired private PersonRepository personRepository; /** * 同时操作多条数据 * 如果操作未成功，回滚到原始数据 */ @Transactional public void insertTwo() &#123; Person personA = new Person(); personA.setName(\"A\"); personA.setAge(20); personRepository.save(personA); Person personB = new Person(); personB.setName(\"B\"); personB.setAge(21); personRepository.save(personB); &#125;&#125; tips: Intellji Idea 使用学生邮箱注册Ultimate版本可以免费使用 Intellji Idea License Server http://jetbrains.tech http://idea.iteblog.com/key.php http://www.aku.vn/idea http://xidea.online 阿里云Maven镜像配置 打开 ~/.m2/setting.xml文件 将下列代码加入到mirrors节点下 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; ​","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Mac上百度网盘的正确使用姿势","date":"2017-02-26T16:09:53.000Z","path":"2017/02/27/ Mac上百度网盘的正确使用姿势/","text":"实现步骤 下载Aria2软件 What is Area2? ​ aria2 是一款支持多种协议的轻量级命令行下载工具 官网介绍： ​ aria2 is a lightweight multi-protocol &amp; multi-source command-line download utility. It supports HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink. aria2 can be manipulated via built-in JSON-RPC and XML-RPC interfaces. 安装方式： 方式一：使用Homebrew安装： 在终端输入命令 1brew install aria2 方式二：官网下载安装： 打开Aira2官网，点击Download进入下载界面。 选择合适的软件版本解压安装即可。 方式三：下载Aira2Gui。(推荐) Aira2Gui是Aira2的图像化界面工具，更符合一般人的使用习惯。 进入下载界面，点击Aria2Gui-v.zip下载压缩包。 或者直接点击下载 安装浏览器插件 下载百度网盘插件 下载地址 安装 将下载完的文件拖拽到Chrome的拓展程序界面完成安装 使用 运行你的Aira2Gui 在Chrome中打开你的百度网盘,随便选中一个文件，你就会发现界面上多个一个’导出下载’按钮。 点击’导出下载’按钮下面的’ARIA2 RPC’就可以直接添加项目到Aira2的下载队列中了。 下载相同文件 对比图百度网盘 Aira2","tags":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/tags/Tools/"}]},{"title":"ButterKnife是怎么帮我们做到这一切的？","date":"2017-01-20T14:19:53.000Z","path":"2017/01/20/ButterKnife是怎么帮我们做到这一切的？/","text":"职责划分在分析原理之前我们可以根据职责将功能实现分为两个部分 编译期对源代码进行处理，动态生成ViewBinder类。 运行期对这些新生成的类进行调用，注入数据到指定的类中。 编译期操作 在开始看源码之前那首先我们要明确java中注解的三种不同的生命周期。 SOURCE： 源码时保留，大多在起校验作用。如：Override、Deprecated RUNTIME运行时保留，可以通过反射机制读取注解的信息 CLASS：编译时保留，在class文件中有效，可以在编译时用来生成辅助代码 前提一般来说依赖注入框架常使用的套路都是运行时通过反射完成注入，不过这样的话对性能影响很大。 而我们今天的ButterKnife则完全避开了这个问题，它使用的是一个名叫编译时解析技术，也就是APT（Anotation Processing Tool）。 这种技术是说在编译器开始工作的时候，会自动查找代码中所有表明生命周期为CLASS的注解，然后找到该注解注册的Processor类，主动调用这个类的process()方法。 我们常见的辅助类XXXActivity_ViewBinding就是在这个时候创建的~ 代码分析： ​ 我们首先进入ButterKnifeProcessor类中,找到系统主动调用的process()方法 然后我们进入查找注解的方法findAndParseTaregets(env)方法中。 因为这里会将所有类型的注解都拿出来做判断，所以我们就只取其一找到遍历@BindView注解的这部分代码。 接着进入parseBindView()查看解析过程 在这个方法中会先对注解元素进行类型判断 然后再获取注解绑定元素的基本信息，因为此时我们走的时@BindView注解的流程，所以对应获取的也是View的ID。 之后我们再进入getOrCreateBindingBuilder()方法中，这个方法返回一个Builder实例。 我们继续深入，点击newBuilder()方法，进入了Builder的实现代码。 这里就是将我们所需要的所有的基本信息获取到，然后再用获取到的信息构建Builder对象的过程。 现在让我们回到刚开始的时候 此时的Map里面就已经储存有了所有的注解元素。 接着就是用Binding中储存的信息生成辅助类了。 不过这里继续点下去的话就到另外的一个框架了，咱是我们就先到这里。 运行时操作​ 运行期进行的操作就比较简单了，首先从ButterKnife.bind()方法进入。 ​ 发现会调用其他多参bind()方法，我们继续点过去。 ​ 接着我们发现，这里首先是通过反射拿到了我们传入进去的Activity类的Class对象，然后又以刚才拿到的Class对象的类型+’$$ViewBinder’反射出来了一个viewBinder 。接着又调用了该对象的bind()方法。 ​ 而ViewBinder就是我们在编译时自动生成的代码，调用此ViewBinder的bind()方法后你会发现，其实它也是使用findViewById(id)的方式获取到View控件的。只不过是它在获取到控件之后又注入到注解元素中的，所以这一切其实我们都没有省略，只不过是ButterKnife这个可爱的框架帮我们代劳了。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Mp3和Amr音频数据采集","date":"2016-11-13T14:07:43.000Z","path":"2016/11/13/Android-mp3和amr音频数据采集/","text":"需求： 使用一份音频输入数据分别采样Mp3和Amr音频编码需要的数据。 前提条件： Mp3文件需要采样率是44.1KHZ的音频数据流 Amr文件需要采样率是8,000 Hz或者16,000 HZ采用率的音频数据流 具体实现： 创建音频采集线程，采样音频数据 12345678910111213141516171819202122232425262728293031323334353637383940public class Recorder implements Runnable&#123; private ArrayList&lt;Integer&gt; hitArray; @Override public void start() &#123; if (isRecording) &#123; Log.e(TAG, \"is recoding\"); return; &#125; //获取指定格式的音频缓冲区数据大小 //指定采样率为44100，单声道，PCM16位编码方式 int bufferSizeInByte = AudioRecord.getMinBufferSize(SAMPLE_RATE, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT); audioBuffer = new short[bufferSizeInByte / 2]; //创建音频采集器，指定音频源为麦克风，其他参数和上面相同 audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSizeInByte); //开始音频采集 audioRecord.startRecording(); isRecording = true; //初始化Mp3编码器 mMp3Format = new MP3Format(); mMp3Format.start(bufferSizeInByte); //开启线程 runningThread = new Thread(this); runningThread.start(); //获取需要取出的short下标List 下文说明 hitArray = getIndexList(); &#125;&#125; 思路 由于amr是码率50fps的。所以每个frame需要的数据源就是8000/50=160个short 现在对应在44100上就是每个frame 44100/50 = 882 个short 然后就是从44100采样的每882个short里拿出160个给amr用 也就是每5.5125个short拿一个short放到amr的Buffer里 这个Buffer每满160就拿去encode 然后接着从audioBuffer里拿 首先如果要保证声音的连续性就得首先获取882个short中这160个short的下标 123456789101112private ArrayList&lt;Integer&gt; getIndexList()&#123; float ratio = (float) (882.0 / 160); ArrayList&lt;Integer&gt; indexList = new ArrayList(); int count = 0; for (int i = 1; i &lt;= 882; i++)&#123; if(i / ratio &gt; count)&#123; indexList.add(i); count++; &#125; &#125; return indexList;&#125; 获取进行编码的数据 12345678910111213141516171819202122232425262728293031323334@Override public void run() &#123; while (isRecording) &#123; //每次采集到的音频流数据 int read = audioRecord.read(audioBuffer, 0, FRAME_SIZE); //判断数据是否正常 if (read == AudioRecord.ERROR_INVALID_OPERATION || read == AudioRecord.ERROR_BAD_VALUE) &#123; Log.i(TAG, \"error:\" + read); continue; &#125; //这里做Mp3encode mMp3Format.formatMp3(mp3AudioBuffer, mp3BufferSize); for (int i = 0; i &lt; read; i++) &#123; for (int i = 0; i &lt; read; i++) &#123; if (sourcePointer == hitArray[hitPointer]) &#123; amrAudioBuffer[targetPointer++] = audioBuffer[i]; hitPointer++; if (hitPointer == 160) &#123; hitPointer = 0; targetPointer = 0; //这里做amrencode amrencode(amrBuffer,160); pcmConsumer.onPcmFeed(amrAudioBuffer, 160); &#125; &#125; if (sourcePointer == 882) &#123; sourcePointer = 0; &#125; else &#123; sourcePointer++; &#125; &#125; &#125; &#125; 坑 后来发现一些移动设备并不支持44.1KHZ的采样率，在AudioRecord.getMinBufferSize() 方法获取音频缓冲区大小的时候返回负数。 在测试了多个设备的可以支持的采样率之后，确定采样率为比较通用的8,000 Hz。 方案 更改音频采集器采样率为8000 Hz 扩充数据，拿取到需要编码的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243@Override public void run() &#123; while (isRecording) &#123; //每次采集到的音频流数据 int read = audioRecord.read(audioBuffer, 0, FRAME_SIZE); //判断数据是否正常 if (read == AudioRecord.ERROR_INVALID_OPERATION || read == AudioRecord.ERROR_BAD_VALUE) &#123; Log.i(TAG, \"error:\" + read); continue; &#125; int mp3BufferSize = 0; for (int i = 0; i &lt; read; i++) &#123; //判断当前的数据需要复制几份 if (i % 2 == 0) &#123; mp3BufferSize += 6; &#125; else &#123; mp3BufferSize += 5; &#125; &#125; //amrencode pcmConsumer.onPcmFeed(audioBuffer, read); //创建一个新数组用来存储用来合成Mp3的数据 mp3AudioBuffer = new short[mp3BufferSize]; int position = 0; for (int i = 0; i &lt; read; i++) &#123; //每一个short复制三份填充到MP3Short数组中 if (i % 2 == 0) &#123; for (int j = 0; j &lt; 6; j++) &#123; mp3AudioBuffer[position] = audioBuffer[i]; position++; &#125; &#125; else &#123; for (int j = 0; j &lt; 5; j++) &#123; mp3AudioBuffer[position] = audioBuffer[i]; position++; &#125; &#125; &#125; //mp3encode mMp3Format.formatMp3(mp3AudioBuffer, mp3BufferSize); &#125; &#125; MP3编码用的是从mp3lame官网下载的源码然后重新编译的mp3lame.so库。 Amr编码使用的是Android自带的media_jni.so库","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"使用xposed框架进行安全检测","date":"2016-11-11T02:18:26.000Z","path":"2016/11/11/框架初步使用与安全检测/","text":"首先在Root的手机上安装Xposed框架，然后新建一个android工程，不需要添加任何Activity。 下载Xposed的jar包，然后在android工程app目录创建lib文件夹，将jar包放置进入并依赖。 修改app下面的build.gradle，将刚添加的jar修改为provided方式 修改manifest文件，加入Xposed模板的必要描述 创建一个java类，在里面写hook代码。 12345678910111213141516171819202122import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class Main implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; //判断包名是否为要 hook 的应用 if(loadPackageParam.packageName.equals(\"要Hook的应用包名\")&#123; //hook 对应类的对应方法 、 XposedHelpers.findAndHookMethod(\"android.widget.TextView\", loadPackageParam.classLoader, \"setText\", CharSequence.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); //将 textView 的 settext 方法的参数修改成了下面的值，所以 APP 里面所以的 TextView 控件都会显示下面的字符串 param.args[0] = \"hook....\"; &#125; &#125;); &#125; &#125; &#125; 创建assets资源文件目录，然后在该目录下创建一个文本文档，名字叫做xposed_init,没有后缀名。在里面写上Hookook的包名再加类名。 将Hook模板安装到手机上，在Xposed installer里面勾选刚安装上的模板并重启手机。 针对有应用被Hook的风险，我们可以进行Hook框架的检测。如果有Hook框架的话，就给用户提示然后退出。 实例代码 12345678910111213141516public void getApplications() &#123; List&lt;PackageInfo&gt; packages = getPackageManager().getInstalledPackages(0); for(int i=0;i&lt;packages.size();i++) &#123; PackageInfo packageInfo = packages.get(i); String name = packageInfo.packageName; //检测手机是否装有 xposed if(name.contains(\"xposed.installer\"))&#123; /* 相应的处理 */ Log.d(\"test:\",\"xposed\"); &#125; &#125;&#125;","tags":[{"name":"应用安全","slug":"应用安全","permalink":"http://yoursite.com/tags/应用安全/"}]},{"title":"拿来即用：App签名校验和Dex文件校验","date":"2016-11-06T00:24:37.000Z","path":"2016/11/06/拿来即用：Android-App签名校验和Dex文件校验/","text":"应用签名校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * Create By HaoRui */public class SignCheck &#123; private Context context; private String cer = null; private String realCer = null; private static final String TAG = \"SignCheck\"; public SignCheck(Context context) &#123; this.context = context; this.cer = getCertificateSHA1Fingerprint(); &#125; public SignCheck(Context context, String realCer) &#123; this.context = context; this.realCer = realCer; this.cer = getCertificateSHA1Fingerprint(); &#125;&lt;!-- more --&gt; public String getRealCer() &#123; return realCer; &#125; /** * 设置正确的签名 * * @param realCer */ public void setRealCer(String realCer) &#123; this.realCer = realCer; &#125; /** * 获取应用的签名 * * @return */ public String getCertificateSHA1Fingerprint() &#123; //获取包管理器 PackageManager pm = context.getPackageManager(); //获取当前要获取 SHA1 值的包名，也可以用其他的包名，但需要注意， //在用其他包名的前提是，此方法传递的参数 Context 应该是对应包的上下文。 String packageName = context.getPackageName(); //返回包括在包中的签名信息 int flags = PackageManager.GET_SIGNATURES; PackageInfo packageInfo = null; try &#123; //获得包的所有内容信息类 packageInfo = pm.getPackageInfo(packageName, flags); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; //签名信息 Signature[] signatures = packageInfo.signatures; byte[] cert = signatures[0].toByteArray(); //将签名转换为字节数组流 InputStream input = new ByteArrayInputStream(cert); //证书工厂类，这个类实现了出厂合格证算法的功能 CertificateFactory cf = null; try &#123; cf = CertificateFactory.getInstance(\"X509\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //X509 证书，X.509 是一种非常通用的证书格式 X509Certificate c = null; try &#123; c = (X509Certificate) cf.generateCertificate(input); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; String hexString = null; try &#123; //加密算法的类，这里的参数可以使 MD4,MD5 等加密算法 MessageDigest md = MessageDigest.getInstance(\"SHA1\"); //获得公钥 byte[] publicKey = md.digest(c.getEncoded()); //字节到十六进制的格式转换 hexString = byte2HexFormatted(publicKey); &#125; catch (NoSuchAlgorithmException e1) &#123; e1.printStackTrace(); &#125; catch (CertificateEncodingException e) &#123; e.printStackTrace(); &#125; return hexString; &#125; //这里是将获取到得编码进行16 进制转换 private String byte2HexFormatted(byte[] arr) &#123; StringBuilder str = new StringBuilder(arr.length * 2); for (int i = 0; i &lt;arr.length; i++) &#123; String h = Integer.toHexString(arr[i]); int l =h.length(); if (l == 1) h = \"0\" + h; if (l &gt; 2) h = h.substring(l - 2, l); str.append(h.toUpperCase()); if (i &lt; (arr.length - 1)) str.append(':'); &#125; return str.toString(); &#125; /** * 检测签名是否正确 * @return true 签名正常 false 签名不正常 */ public boolean check() &#123; if (this.realCer != null) &#123; cer = cer.trim(); realCer = realCer.trim(); if (this.cer.equals(this.realCer)) &#123; return true; &#125; &#125;else &#123; Log.e(TAG, \"未给定真实的签名 SHA-1 值\"); &#125; return false; &#125;&#125; 使用方法： 首先使用 keytool 获取签名的 sha-1 值，命令为 keytool -list -v -keystore xxx.jks （将 xx.jks 换成你的应用签名所用文件， 这里会提示输入 keystore 的密码 ps：签名文件在eclipse 是 .keystore 文件， 在 Android Studio中就是 .jks 文件）） 然后使用如下代码校验签名： 1234567SignCheck signCheck = new SignCheck(this,\"27:19:6E:38:6B:87:5E:76:AD:F7:00:E7:EA:84:E4:C6:EE:E3:3D:FA\"); if(signCheck.check()) &#123; //TODO 签名正常 &#125;else &#123; //TODO 签名不正确 newAlertDialog.Builder(this).setMessage(\"请前往官方渠道下载正版 app， http://.....\").setPositiveButton(\"确定\",null).show(); &#125; Dex文件校验123456789101112131415161718private boolean checkcrc()&#123; boolean checkResult = false; long crc = Long.parseLong(getString(R.string.crc));//获取字符资源中预埋的crc值 ZipFile zf; try&#123; String path = getApplicationContext().getPackageCodePath();//获取apk安装路径 zf = new ZipFile(path);//将apk封装成zip对象 ZipEntry ze = zf.getEntry(\"classes.dex\");//获取apk中的classes.dex long CurrentCRC = ze.getCrc();//计算当前应用classes.dex的crc值 if(CurrentCRC != crc)&#123;//crc值对比 checkResult = true; &#125; &#125;catch(IOException e)&#123; handleError(); checkResult = false; &#125; return checkResult;&#125;","tags":[{"name":"应用安全","slug":"应用安全","permalink":"http://yoursite.com/tags/应用安全/"}]},{"title":"使用Netty框架实现Andorid长连接","date":"2016-10-20T14:07:22.000Z","path":"2016/10/20/Andorid长连接具体实现方式/","text":"NIO，即Non Blocking IO，非阻塞IO，在JAVA中NIO的核心就是Selector机制。简单而言，创建一个Socket Channel，并将其注册到一个Selector上（多路复用器），这个Selector将会“关注”Channel上发生的IO读写事件，并在事件发生（数据就绪）后执行相关的处理逻辑。对于阻塞IO，它需要在read()、write()操作上阻塞而直到数据操作完毕，但是NIO则不需要，只有当Selector检测到此Channel上有事件时才会触发调用read、write操作。 需要实现的功能 创建后台服务，在服务中和服务器建立长连接 定时发送心跳包 断线重连机制 具体思路： 使用IdleStateHandler来检测读写操作的空闲时间 客户端write空闲5s后向服务端发送一个心跳包 在发送下一个心跳包之前，未收到服务端应答，失败计数器加一 收到服务端应答，失败计数器清零 超过没有收到应答最大次数后断开连接 重新和服务器建立连接，如果连接失败，会在固定时间间隔之后重新连接。 具体实现 引入包 123dependencies &#123; compile 'io.netty:netty-all:5.0.0.Alpha2'&#125; 初始化Clinet服务，和后台建立长连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void startServer() &#123; eventLoopGroup = new NioEventLoopGroup(); // Client服务启动器 3.x的ClientBootstrap // 改为Bootstrap，且构造函数变化很大，这里用无参构造。 bootstrap = new Bootstrap(); try &#123; // 指定channel类型 bootstrap.channel(NioSocketChannel.class); //设置TCP协议的属性 bootstrap.option(ChannelOption.SO_KEEPALIVE, true); // 指定EventLoopGroup bootstrap.group(eventLoopGroup); //指定地址 bootstrap.remoteAddress(ConstsNet.host, ConstsNet.port); // 指定Handler bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //回行换车解码器 socketChannel.pipeline().addLast(new LineBasedFrameDecoder(2048)); //自定义数据编解码器 socketChannel.pipeline().addLast(new DataDecoder()); socketChannel.pipeline().addLast(new DataEncoder()); // 自己的逻辑Handler socketChannel.pipeline().addLast(new KeepAliveServerInitializer()); &#125; &#125;); //同步创建连接 ChannelFuture future = bootstrap.connect(ConstsNet.host, ConstsNet.port).sync(); if (future.isSuccess()) &#123; //Channel中所有的操作均是异步的，IO操作都会返回一个ChannelFuture实例： socketChannel = (SocketChannel) future.channel(); //发送心跳包 socketChannel.writeAndFlush(&#123;code:'login'&#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Utils.showToast(this, getResources().getString(R.string.action_networke)); if (!isStop) &#123; //出错之后开启断线重连 connServer(); &#125; &#125;&#125; 创建延迟任务，以固定的时间间隔重新连接服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243private void connServer() &#123; try &#123; isStop = false; if (executorService != null) &#123; executorService.shutdown(); &#125; executorService = Executors.newScheduledThreadPool(1); //本次任务执行完成后，需要延迟设定的延迟时间，才会执行新的任务 executorService.scheduleWithFixedDelay(new Runnable() &#123; boolean isConnSucc = true; @Override public void run() &#123; try &#123; // 重置计数器 unRecPongTimes = 0; // 连接服务端 if (socketChannel != null &amp;&amp; socketChannel.isOpen()) &#123; socketChannel.close(); &#125; ChannelFuture future = bootstrap.connect(ConstsNet.host, ConstsNet.port).sync(); if (future.isSuccess()) &#123; socketChannel = (SocketChannel) future.channel(); socketChannel.writeAndFlush(&#123;code:'login'&#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); isConnSucc = false; &#125; finally &#123; if (isConnSucc) &#123; if (executorService != null) &#123; //如果连接成功 关闭延时任务 executorService.shutdown(); &#125; &#125; &#125; &#125; &#125;, RE_CONN_WAIT_SECONDS, RE_CONN_WAIT_SECONDS, TimeUnit.SECONDS); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 设置心跳包发送间隔和心跳包Handler 12345678910111213private class KeepAliveServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new LineBasedFrameDecoder(2048)); //检测读写操作的空闲时间 ch.pipeline().addLast(new IdleStateHandler(0, WRITE_WAIT_SECONDS, 0)); ch.pipeline().addLast(new DataDecoder()); ch.pipeline().addLast(new DataEncoder()); //设置心跳处理器 ch.pipeline().addLast(new Heartbeat()); &#125; &#125; 心跳包处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private class Heartbeat extends SimpleChannelInboundHandler&lt;String&gt; &#123; JSONObject data; /** * 每一次收到消息时触发。 * @param ctx * @param msg * @throws Exception */ @Override protected void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception &#123; if (msg == null) &#123; return; &#125; data = new JSONObject(msg); if (!data.has(\"code\")) &#123; return; &#125; // 失败计数器清零 unRecPongTimes = 0; //处理从服务端接收到的消息 TODO &#125; //如果在指定的时间内容没有write事件，就会触发该方法 public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if (evt instanceof IdleStateEvent) &#123; IdleStateEvent event = (IdleStateEvent) evt; if (event.state() == IdleState.READER_IDLE) &#123; Logger.i(\"读超时)\"); &#125; else if (event.state() == IdleState.WRITER_IDLE) &#123; if (unRecPongTimes &lt; MAX_UN_REC_PONG_TIMES) &#123; //发送下一个心跳包，检测服务端是否还存活 ctx.channel().writeAndFlush(\"&#123;code:'ping'&#125;\"); unRecPongTimes++; &#125; else &#123; ctx.channel().close(); &#125; &#125; else if (event.state() == IdleState.ALL_IDLE) &#123; /*总超时*/ Logger.i(\"总超时)\"); &#125; &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; Logger.i(\"错误原因：\" + cause.getMessage()); if (data != null) &#123; &#125; ctx.channel().close(); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); &#125; /** * 连接断开 * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; ctx.close(); /* * 重连 */ if (!isStop) &#123; connServer(); &#125; Logger.i(\"客户端失效\"); &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android开发小技巧速查整理","date":"2016-10-12T00:48:26.000Z","path":"2016/10/12/应用开发小技巧速查/","text":"Activity.startActivities() 常用于在应用程序中间启动其他的Activity。 TextUtils.isEmpty() 用于检测是否为空。 Html.fromHtml() 用于生成一个Html,参数可以是一个字符串 TextView.setError() 验证用户输入,输入错误时可以设置错误提示。 Build.VERSION_CODES 这个标明了当前的版本号,点进去可以看到各个版本的不同特性。 Log.getStackTraceString() 日志类工具 LayoutInflater.from() 用于Inflate一个layout,参数是layout的id ViewConfiguration.getScaledTouchSlop() 这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动. PhoneNumberUtils.convertKeypadLettersToDigits 将字母转换为数字,类似于T9输入法, Context.getCacheDir() 获取缓存数据文件夹的路径 argbEvaluator.evaluate(fraction,startValue,endValue); 一个在两种色彩中，通过偏移量计算出另一个色彩的类。 用于处理颜色的渐变 ContextThemeWrapper 运行的时候修改主题。 Space 用来分隔不同的控件，其中形成一个空白的区域。在初始化的时候会跳过Draw这个过程。 ValueAnimator.reverse() 顺畅的取消动画效果 DateUtils.formatDateTime() 用来进行区域格式化工作，输出格式化和本地化的时间或者日期。 TypedValue.applyDimension() 对sp dp 和 px 之间进行单位转换 AlarmManager.setInexactRepeating 设置非准确闹钟。 在一些指定的时间点启动我们的服务进行处理事件。 当使用setInexactRepeating()时，系统可以在同一时间触发多个应用的闹钟，从而有效的减少设备的唤醒次数。 Formatter.formatFileSize() 一个区域化的文件大小格式化工具。把大小转换为MB，G，KB之类的字符串。 ActionBar.hide() 隐藏和显示ActionBar Linkify.addLinks() 在Text上添加链接 StaticLayout 绘制文本的时候指定绘制区域的宽度 Activity.onBackPressed() 管理back键的方法,在Activity中重写该方法可以用来处理back键的事件 GestureDetector 用来监听手势事件，比如点击，长按，慢滑动，快滑动 DrawFilter 可以暂时修改所使用的画笔，可以禁用/启用抗锯齿,或改变画的颜色。 ActivityManager.getMemoryClass() 获取机器剩余内存 ViewStub 在程序运行过程中动态的根据当前条件来决定是否显示某个控件或布局 ViewStub对象是一个看不见的，零大小的视图，并在程序运行时根据需要进行动态加载。只有ViewStub对象被设置为可见，或是调用了ViewStub.inflate()方法时，ViewStub对象所指向的布局才会被实例化，并加载到指向的父布局中。 SystemClock.sleep() 忽略中断异常的sleep操作 DisplayMetrics.density 获取设备像素密度 Pair.create() 构建类和构造器的方法。 UrlQuerySanitizer 一个用来处理url链接的工具类,可以很方便的获取url中的query参数 Fragment.setArguments 在初始化Fragment时向Fragment传参的一个很方便的接口，在Fragment中使用getArguments()来接收。 DialogFragment.setShowsDialog () 用于在Activity的内容之上展示一个模态的对话框。 有着和Fragment基本一致的声明周期。 FragmentManager.enableDebugLogging () 在需要观察 Fragment 状态的时候会有帮助。 LocalBroadcastManager 只能用于应用内通信，安全性更好，同时拥有更高的运行效率。 PhoneNumberUtils.formatNumber () PhoneNumverUtils提供了一系列方法用来格式化电话号码 Application.registerActivityLifecycleCallback(callback) 给Activity设置生命周期回调，可以监听到Activity的Created、Destory和Paused等。 versionNameSuffix 在Gradle脚本中使用该标签可以修改在Manifest中定义的VersionName -nodp 把一些不能被拉伸的图片放在 drawable-nodpi 中，此图片将不会被放大，以原大小显示。 Activity.recreate() 强制一个Activity重新创建自己一个新实例的方法，调用该方法目标Activity会重新走一遍自己的生命周期 PackageManager.checkSignatures () 检查两个apk安装包的签名是否一样，一样的话返回值&gt;0否则返回值&lt;0 Activity.isChangingConfigurations () 通常在onStop()函数中通过该函数来判断当前的Activity是否正在改变Configuration，从而来决定该Activity中引用的一些资源该如何处理， SearchRecentSuggestionsProvider 通常用与写入历史和读取搜索记录 ViewTreeObserver 可以注册监听正在屏幕上显示的视图树中任何视图状态的变化，可以用来视图初始化完成后获取某个控件的尺寸。 DatabaseUtils 一个包含各种数据库操作的使用工具类。 android:weightSum (LinearLayout) 可以用来定义总的 weight 数量。 android:duplicateParentState (View) 和父组件保持同样的状态。 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）。 需注意这两个属性只是传递点击状态而不会执行点击事件。 android:clipChildren (ViewGroup) 是否限制子View在其范围内 设置这个属性后子控件就可以在父控件的范围之外进行绘制了 android:fillViewport (ScrollView) 解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。 android:tileMode (BitmapDrawable) 用来设置Bitmap显示方式，有平铺、重复等。 android:enterFadeDuration/android:exitFadeDuration (Drawables) 为selector设置渐变效果 android:scaleType (ImageView) 设置ImageView 中图片的显示方式 Merge 优化UI结构，删除多余层级。 当你使用include标签添加布局文件时，系统会忽略merge节点并且直接添加它的子节点。 AtomicFile 保证文件的写入完成，并在写入之后删除备份文件。原子性 ViewDragHelper 它定义了一组有用的操作和状态追踪，允许用户在父ViewGroup中拖动并且重新定位子View ThumbnailUtil 帮助创建缩略图，包括视频缩略图 Context.getExternalFilesDir() getCacheDir()：获取/data/data/application package/cache目录 getFilesDir()：获取/data/data/application package/files目录 Context.getExternalFilesDir()：获取 SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据 Context.getExternalCacheDir()：获取SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据 ​ SparseArray SparseArray是Android为类型的HashMap专门写的类，目的是为了提供效率，其核心算法是半分查找法。 比 HashMap 节省内存，大概节省 35%左右的内存。 PackageManager.setComponentEnabledSetting() 使用这个方法可以开启和禁用四大组件。比如关掉一个当前不用的广播接收器。 SQLiteDatabase.yieldIfContendedSafely() 暂时停止一个数据库事务 这个方法表示我现在执行我的多次数据库操作，如果碰到其他的数据库操作，我先让别的操作完 再执行我的操作。 Environment.getExternalStoragePublicDirectory() 获取外部存储卡的公共目录 View.generateViewId() 动态生成控件的ID。 ActivityManager.clearApplicationUserData() 一键清理你的app产生的用户数据 API 19以上可以通过反射调用，需要应用具有android.permission.CLEAR_APP_USER_DATA权限 Context.createConfigurationContext() 自定义你的配置环境信息。 ActivityOptions 方便的定义两个Activity切换的动画。 ViewParent.requestDisallowInterceptTouchEvent() 使父控件不拦截当前的Touch事件 Fragment . setUserVisibleHint() 重写Fragment中的该方法，实现 fragment 对用户可见时才加载资源（延迟加载）。 该方法优先于oncreat()方法被调用 View.hasOverlappingRendering 告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程。 原理：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。 AutoScrollHelper 用于控件边缘触发自动滚动。 实现场景:歌词自动滚动 TouchSlop 最小的滑动距离， VelocityTracker 速度跟踪,跟踪触摸屏事件的速率 AlphabetIndexer 字母索引辅助类,实现对链表类型的数据进行快速索引。 ArrayMap 内部由两个数组维护的Array。 比 HashMap 更高的内存效率，但比 HashMap 慢，不适合有大量数据的场景。 ArrayMap相对于SparseArray，特点就是key值类型不受限 采用二分法查找 参考：Android Tips Round-Up 知乎问题：Android开发中，有哪些让你觉得相见恨晚的方法、类或接口？ #推荐阅读：awesome-android-tips 项目","tags":[{"name":"Tips","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"}]},{"title":"Hello World","date":"2016-10-11T10:30:37.000Z","path":"2016/10/11/hello-world/","text":"迷雾之中，顾自前行。","tags":[]}]