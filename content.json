[{"title":"Mac上百度网盘的正确使用姿势","date":"2017-02-26T16:09:53.000Z","path":"2017/02/27/ Mac上百度网盘的正确使用姿势/","text":"实现步骤 下载Aria2软件 What is Area2? ​ aria2 是一款支持多种协议的轻量级命令行下载工具 官网介绍： ​ aria2 is a lightweight multi-protocol &amp; multi-source command-line download utility. It supports HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink. aria2 can be manipulated via built-in JSON-RPC and XML-RPC interfaces. 安装方式： 方式一：使用Homebrew安装： 在终端输入命令 1brew install aria2 方式二：官网下载安装： 打开Aira2官网，点击Download进入下载界面。 选择合适的软件版本解压安装即可。 方式三：下载Aira2Gui。(推荐) Aira2Gui是Aira2的图像化界面工具，更符合一般人的使用习惯。 进入下载界面，点击Aria2Gui-v.zip下载压缩包。 或者直接点击下载 安装浏览器插件 下载百度网盘插件 下载地址 安装 将下载完的文件拖拽到Chrome的拓展程序界面完成安装 使用 运行你的Aira2Gui 在Chrome中打开你的百度网盘,随便选中一个文件，你就会发现界面上多个一个’导出下载’按钮。 点击’导出下载’按钮下面的’ARIA2 RPC’就可以直接添加项目到Aira2的下载队列中了。 下载相同文件 对比图百度网盘 Aira2","tags":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/tags/Tools/"}]},{"title":"ButterKnife是怎么帮我们做到这一切的？","date":"2017-01-20T14:19:53.000Z","path":"2017/01/20/ButterKnife是怎么帮我们做到这一切的？/","text":"职责划分在分析原理之前我们可以根据职责将功能实现分为两个部分 编译期对源代码进行处理，动态生成ViewBinder类。 运行期对这些新生成的类进行调用，注入数据到指定的类中。 编译期操作 在开始看源码之前那首先我们要明确java中注解的三种不同的生命周期。 SOURCE： 源码时保留，大多在起校验作用。如：Override、Deprecated RUNTIME运行时保留，可以通过反射机制读取注解的信息 CLASS：编译时保留，在class文件中有效，可以在编译时用来生成辅助代码 前提一般来说依赖注入框架常使用的套路都是运行时通过反射完成注入，不过这样的话对性能影响很大。 而我们今天的ButterKnife则完全避开了这个问题，它使用的是一个名叫编译时解析技术，也就是APT（Anotation Processing Tool）。 这种技术是说在编译器开始工作的时候，会自动查找代码中所有表明生命周期为CLASS的注解，然后找到该注解注册的Processor类，主动调用这个类的process()方法。 我们常见的辅助类XXXActivity_ViewBinding就是在这个时候创建的~ 代码分析： ​ 我们首先进入ButterKnifeProcessor类中,找到系统主动调用的process()方法 然后我们进入查找注解的方法findAndParseTaregets(env)方法中。 因为这里会将所有类型的注解都拿出来做判断，所以我们就只取其一找到遍历@BindView注解的这部分代码。 接着进入parseBindView()查看解析过程 在这个方法中会先对注解元素进行类型判断 然后再获取注解绑定元素的基本信息，因为此时我们走的时@BindView注解的流程，所以对应获取的也是View的ID。 之后我们再进入getOrCreateBindingBuilder()方法中，这个方法返回一个Builder实例。 我们继续深入，点击newBuilder()方法，进入了Builder的实现代码。 这里就是将我们所需要的所有的基本信息获取到，然后再用获取到的信息构建Builder对象的过程。 现在让我们回到刚开始的时候 此时的Map里面就已经储存有了所有的注解元素。 接着就是用Binding中储存的信息生成辅助类了。 不过这里继续点下去的话就到另外的一个框架了，咱是我们就先到这里。 运行时操作​ 运行期进行的操作就比较简单了，首先从ButterKnife.bind()方法进入。 ​ 发现会调用其他多参bind()方法，我们继续点过去。 ​ 接着我们发现，这里首先是通过反射拿到了我们传入进去的Activity类的Class对象，然后又以刚才拿到的Class对象的类型+’$$ViewBinder’反射出来了一个viewBinder 。接着又调用了该对象的bind()方法。 ​ 而ViewBinder就是我们在编译时自动生成的代码，调用此ViewBinder的bind()方法后你会发现，其实它也是使用findViewById(id)的方式获取到View控件的。只不过是它在获取到控件之后又注入到注解元素中的，所以这一切其实我们都没有省略，只不过是ButterKnife这个可爱的框架帮我们代劳了。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Mp3和Amr音频数据采集","date":"2016-11-13T14:07:43.000Z","path":"2016/11/13/Android-mp3和amr音频数据采集/","text":"需求： 使用一份音频输入数据分别采样Mp3和Amr音频编码需要的数据。 前提条件： Mp3文件需要采样率是44.1KHZ的音频数据流 Amr文件需要采样率是8,000 Hz或者16,000 HZ采用率的音频数据流 具体实现： 创建音频采集线程，采样音频数据 12345678910111213141516171819202122232425262728293031323334353637383940public class Recorder implements Runnable&#123; private ArrayList&lt;Integer&gt; hitArray; @Override public void start() &#123; if (isRecording) &#123; Log.e(TAG, \"is recoding\"); return; &#125; //获取指定格式的音频缓冲区数据大小 //指定采样率为44100，单声道，PCM16位编码方式 int bufferSizeInByte = AudioRecord.getMinBufferSize(SAMPLE_RATE, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT); audioBuffer = new short[bufferSizeInByte / 2]; //创建音频采集器，指定音频源为麦克风，其他参数和上面相同 audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSizeInByte); //开始音频采集 audioRecord.startRecording(); isRecording = true; //初始化Mp3编码器 mMp3Format = new MP3Format(); mMp3Format.start(bufferSizeInByte); //开启线程 runningThread = new Thread(this); runningThread.start(); //获取需要取出的short下标List 下文说明 hitArray = getIndexList(); &#125;&#125; 思路 由于amr是码率50fps的。所以每个frame需要的数据源就是8000/50=160个short 现在对应在44100上就是每个frame 44100/50 = 882 个short 然后就是从44100采样的每882个short里拿出160个给amr用 也就是每5.5125个short拿一个short放到amr的Buffer里 这个Buffer每满160就拿去encode 然后接着从audioBuffer里拿 首先如果要保证声音的连续性就得首先获取882个short中这160个short的下标 123456789101112private ArrayList&lt;Integer&gt; getIndexList()&#123; float ratio = (float) (882.0 / 160); ArrayList&lt;Integer&gt; indexList = new ArrayList(); int count = 0; for (int i = 1; i &lt;= 882; i++)&#123; if(i / ratio &gt; count)&#123; indexList.add(i); count++; &#125; &#125; return indexList;&#125; 获取进行编码的数据 12345678910111213141516171819202122232425262728293031323334@Override public void run() &#123; while (isRecording) &#123; //每次采集到的音频流数据 int read = audioRecord.read(audioBuffer, 0, FRAME_SIZE); //判断数据是否正常 if (read == AudioRecord.ERROR_INVALID_OPERATION || read == AudioRecord.ERROR_BAD_VALUE) &#123; Log.i(TAG, \"error:\" + read); continue; &#125; //这里做Mp3encode mMp3Format.formatMp3(mp3AudioBuffer, mp3BufferSize); for (int i = 0; i &lt; read; i++) &#123; for (int i = 0; i &lt; read; i++) &#123; if (sourcePointer == hitArray[hitPointer]) &#123; amrAudioBuffer[targetPointer++] = audioBuffer[i]; hitPointer++; if (hitPointer == 160) &#123; hitPointer = 0; targetPointer = 0; //这里做amrencode amrencode(amrBuffer,160); pcmConsumer.onPcmFeed(amrAudioBuffer, 160); &#125; &#125; if (sourcePointer == 882) &#123; sourcePointer = 0; &#125; else &#123; sourcePointer++; &#125; &#125; &#125; &#125; 坑 后来发现一些移动设备并不支持44.1KHZ的采样率，在AudioRecord.getMinBufferSize() 方法获取音频缓冲区大小的时候返回负数。 在测试了多个设备的可以支持的采样率之后，确定采样率为比较通用的8,000 Hz。 方案 更改音频采集器采样率为8000 Hz 扩充数据，拿取到需要编码的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243@Override public void run() &#123; while (isRecording) &#123; //每次采集到的音频流数据 int read = audioRecord.read(audioBuffer, 0, FRAME_SIZE); //判断数据是否正常 if (read == AudioRecord.ERROR_INVALID_OPERATION || read == AudioRecord.ERROR_BAD_VALUE) &#123; Log.i(TAG, \"error:\" + read); continue; &#125; int mp3BufferSize = 0; for (int i = 0; i &lt; read; i++) &#123; //判断当前的数据需要复制几份 if (i % 2 == 0) &#123; mp3BufferSize += 6; &#125; else &#123; mp3BufferSize += 5; &#125; &#125; //amrencode pcmConsumer.onPcmFeed(audioBuffer, read); //创建一个新数组用来存储用来合成Mp3的数据 mp3AudioBuffer = new short[mp3BufferSize]; int position = 0; for (int i = 0; i &lt; read; i++) &#123; //每一个short复制三份填充到MP3Short数组中 if (i % 2 == 0) &#123; for (int j = 0; j &lt; 6; j++) &#123; mp3AudioBuffer[position] = audioBuffer[i]; position++; &#125; &#125; else &#123; for (int j = 0; j &lt; 5; j++) &#123; mp3AudioBuffer[position] = audioBuffer[i]; position++; &#125; &#125; &#125; //mp3encode mMp3Format.formatMp3(mp3AudioBuffer, mp3BufferSize); &#125; &#125; MP3编码用的是从mp3lame官网下载的源码然后重新编译的mp3lame.so库。 Amr编码使用的是Android自带的media_jni.so库","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"使用xposed框架进行安全检测","date":"2016-11-11T02:18:26.000Z","path":"2016/11/11/框架初步使用与安全检测/","text":"首先在Root的手机上安装Xposed框架，然后新建一个android工程，不需要添加任何Activity。 下载Xposed的jar包，然后在android工程app目录创建lib文件夹，将jar包放置进入并依赖。 修改app下面的build.gradle，将刚添加的jar修改为provided方式 修改manifest文件，加入Xposed模板的必要描述 创建一个java类，在里面写hook代码。 12345678910111213141516171819202122import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.XC_MethodHook; import de.robv.android.xposed.XposedHelpers; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class Main implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; //判断包名是否为要 hook 的应用 if(loadPackageParam.packageName.equals(\"要Hook的应用包名\")&#123; //hook 对应类的对应方法 、 XposedHelpers.findAndHookMethod(\"android.widget.TextView\", loadPackageParam.classLoader, \"setText\", CharSequence.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); //将 textView 的 settext 方法的参数修改成了下面的值，所以 APP 里面所以的 TextView 控件都会显示下面的字符串 param.args[0] = \"hook....\"; &#125; &#125;); &#125; &#125; &#125; 创建assets资源文件目录，然后在该目录下创建一个文本文档，名字叫做xposed_init,没有后缀名。在里面写上Hookook的包名再加类名。 将Hook模板安装到手机上，在Xposed installer里面勾选刚安装上的模板并重启手机。 针对有应用被Hook的风险，我们可以进行Hook框架的检测。如果有Hook框架的话，就给用户提示然后退出。 实例代码 12345678910111213141516public void getApplications() &#123; List&lt;PackageInfo&gt; packages = getPackageManager().getInstalledPackages(0); for(int i=0;i&lt;packages.size();i++) &#123; PackageInfo packageInfo = packages.get(i); String name = packageInfo.packageName; //检测手机是否装有 xposed if(name.contains(\"xposed.installer\"))&#123; /* 相应的处理 */ Log.d(\"test:\",\"xposed\"); &#125; &#125;&#125;","tags":[{"name":"应用安全","slug":"应用安全","permalink":"http://yoursite.com/tags/应用安全/"}]},{"title":"拿来即用：App签名校验和Dex文件校验","date":"2016-11-06T00:24:37.000Z","path":"2016/11/06/拿来即用：Android-App签名校验和Dex文件校验/","text":"应用签名校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * Create By HaoRui */public class SignCheck &#123; private Context context; private String cer = null; private String realCer = null; private static final String TAG = \"SignCheck\"; public SignCheck(Context context) &#123; this.context = context; this.cer = getCertificateSHA1Fingerprint(); &#125; public SignCheck(Context context, String realCer) &#123; this.context = context; this.realCer = realCer; this.cer = getCertificateSHA1Fingerprint(); &#125;&lt;!-- more --&gt; public String getRealCer() &#123; return realCer; &#125; /** * 设置正确的签名 * * @param realCer */ public void setRealCer(String realCer) &#123; this.realCer = realCer; &#125; /** * 获取应用的签名 * * @return */ public String getCertificateSHA1Fingerprint() &#123; //获取包管理器 PackageManager pm = context.getPackageManager(); //获取当前要获取 SHA1 值的包名，也可以用其他的包名，但需要注意， //在用其他包名的前提是，此方法传递的参数 Context 应该是对应包的上下文。 String packageName = context.getPackageName(); //返回包括在包中的签名信息 int flags = PackageManager.GET_SIGNATURES; PackageInfo packageInfo = null; try &#123; //获得包的所有内容信息类 packageInfo = pm.getPackageInfo(packageName, flags); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; //签名信息 Signature[] signatures = packageInfo.signatures; byte[] cert = signatures[0].toByteArray(); //将签名转换为字节数组流 InputStream input = new ByteArrayInputStream(cert); //证书工厂类，这个类实现了出厂合格证算法的功能 CertificateFactory cf = null; try &#123; cf = CertificateFactory.getInstance(\"X509\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //X509 证书，X.509 是一种非常通用的证书格式 X509Certificate c = null; try &#123; c = (X509Certificate) cf.generateCertificate(input); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; String hexString = null; try &#123; //加密算法的类，这里的参数可以使 MD4,MD5 等加密算法 MessageDigest md = MessageDigest.getInstance(\"SHA1\"); //获得公钥 byte[] publicKey = md.digest(c.getEncoded()); //字节到十六进制的格式转换 hexString = byte2HexFormatted(publicKey); &#125; catch (NoSuchAlgorithmException e1) &#123; e1.printStackTrace(); &#125; catch (CertificateEncodingException e) &#123; e.printStackTrace(); &#125; return hexString; &#125; //这里是将获取到得编码进行16 进制转换 private String byte2HexFormatted(byte[] arr) &#123; StringBuilder str = new StringBuilder(arr.length * 2); for (int i = 0; i &lt;arr.length; i++) &#123; String h = Integer.toHexString(arr[i]); int l =h.length(); if (l == 1) h = \"0\" + h; if (l &gt; 2) h = h.substring(l - 2, l); str.append(h.toUpperCase()); if (i &lt; (arr.length - 1)) str.append(':'); &#125; return str.toString(); &#125; /** * 检测签名是否正确 * @return true 签名正常 false 签名不正常 */ public boolean check() &#123; if (this.realCer != null) &#123; cer = cer.trim(); realCer = realCer.trim(); if (this.cer.equals(this.realCer)) &#123; return true; &#125; &#125;else &#123; Log.e(TAG, \"未给定真实的签名 SHA-1 值\"); &#125; return false; &#125;&#125; 使用方法： 首先使用 keytool 获取签名的 sha-1 值，命令为 keytool -list -v -keystore xxx.jks （将 xx.jks 换成你的应用签名所用文件， 这里会提示输入 keystore 的密码 ps：签名文件在eclipse 是 .keystore 文件， 在 Android Studio中就是 .jks 文件）） 然后使用如下代码校验签名： 1234567SignCheck signCheck = new SignCheck(this,\"27:19:6E:38:6B:87:5E:76:AD:F7:00:E7:EA:84:E4:C6:EE:E3:3D:FA\"); if(signCheck.check()) &#123; //TODO 签名正常 &#125;else &#123; //TODO 签名不正确 newAlertDialog.Builder(this).setMessage(\"请前往官方渠道下载正版 app， http://.....\").setPositiveButton(\"确定\",null).show(); &#125; Dex文件校验123456789101112131415161718private boolean checkcrc()&#123; boolean checkResult = false; long crc = Long.parseLong(getString(R.string.crc));//获取字符资源中预埋的crc值 ZipFile zf; try&#123; String path = getApplicationContext().getPackageCodePath();//获取apk安装路径 zf = new ZipFile(path);//将apk封装成zip对象 ZipEntry ze = zf.getEntry(\"classes.dex\");//获取apk中的classes.dex long CurrentCRC = ze.getCrc();//计算当前应用classes.dex的crc值 if(CurrentCRC != crc)&#123;//crc值对比 checkResult = true; &#125; &#125;catch(IOException e)&#123; handleError(); checkResult = false; &#125; return checkResult;&#125;","tags":[{"name":"应用安全","slug":"应用安全","permalink":"http://yoursite.com/tags/应用安全/"}]},{"title":"使用Netty框架实现Andorid长连接","date":"2016-10-20T14:07:22.000Z","path":"2016/10/20/Andorid长连接具体实现方式/","text":"NIO，即Non Blocking IO，非阻塞IO，在JAVA中NIO的核心就是Selector机制。简单而言，创建一个Socket Channel，并将其注册到一个Selector上（多路复用器），这个Selector将会“关注”Channel上发生的IO读写事件，并在事件发生（数据就绪）后执行相关的处理逻辑。对于阻塞IO，它需要在read()、write()操作上阻塞而直到数据操作完毕，但是NIO则不需要，只有当Selector检测到此Channel上有事件时才会触发调用read、write操作。 需要实现的功能 创建后台服务，在服务中和服务器建立长连接 定时发送心跳包 断线重连机制 具体思路： 使用IdleStateHandler来检测读写操作的空闲时间 客户端write空闲5s后向服务端发送一个心跳包 在发送下一个心跳包之前，未收到服务端应答，失败计数器加一 收到服务端应答，失败计数器清零 超过没有收到应答最大次数后断开连接 重新和服务器建立连接，如果连接失败，会在固定时间间隔之后重新连接。 具体实现 引入包 123dependencies &#123; compile 'io.netty:netty-all:5.0.0.Alpha2'&#125; 初始化Clinet服务，和后台建立长连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void startServer() &#123; eventLoopGroup = new NioEventLoopGroup(); // Client服务启动器 3.x的ClientBootstrap // 改为Bootstrap，且构造函数变化很大，这里用无参构造。 bootstrap = new Bootstrap(); try &#123; // 指定channel类型 bootstrap.channel(NioSocketChannel.class); //设置TCP协议的属性 bootstrap.option(ChannelOption.SO_KEEPALIVE, true); // 指定EventLoopGroup bootstrap.group(eventLoopGroup); //指定地址 bootstrap.remoteAddress(ConstsNet.host, ConstsNet.port); // 指定Handler bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //回行换车解码器 socketChannel.pipeline().addLast(new LineBasedFrameDecoder(2048)); //自定义数据编解码器 socketChannel.pipeline().addLast(new DataDecoder()); socketChannel.pipeline().addLast(new DataEncoder()); // 自己的逻辑Handler socketChannel.pipeline().addLast(new KeepAliveServerInitializer()); &#125; &#125;); //同步创建连接 ChannelFuture future = bootstrap.connect(ConstsNet.host, ConstsNet.port).sync(); if (future.isSuccess()) &#123; //Channel中所有的操作均是异步的，IO操作都会返回一个ChannelFuture实例： socketChannel = (SocketChannel) future.channel(); //发送心跳包 socketChannel.writeAndFlush(&#123;code:'login'&#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Utils.showToast(this, getResources().getString(R.string.action_networke)); if (!isStop) &#123; //出错之后开启断线重连 connServer(); &#125; &#125;&#125; 创建延迟任务，以固定的时间间隔重新连接服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243private void connServer() &#123; try &#123; isStop = false; if (executorService != null) &#123; executorService.shutdown(); &#125; executorService = Executors.newScheduledThreadPool(1); //本次任务执行完成后，需要延迟设定的延迟时间，才会执行新的任务 executorService.scheduleWithFixedDelay(new Runnable() &#123; boolean isConnSucc = true; @Override public void run() &#123; try &#123; // 重置计数器 unRecPongTimes = 0; // 连接服务端 if (socketChannel != null &amp;&amp; socketChannel.isOpen()) &#123; socketChannel.close(); &#125; ChannelFuture future = bootstrap.connect(ConstsNet.host, ConstsNet.port).sync(); if (future.isSuccess()) &#123; socketChannel = (SocketChannel) future.channel(); socketChannel.writeAndFlush(&#123;code:'login'&#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); isConnSucc = false; &#125; finally &#123; if (isConnSucc) &#123; if (executorService != null) &#123; //如果连接成功 关闭延时任务 executorService.shutdown(); &#125; &#125; &#125; &#125; &#125;, RE_CONN_WAIT_SECONDS, RE_CONN_WAIT_SECONDS, TimeUnit.SECONDS); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 设置心跳包发送间隔和心跳包Handler 12345678910111213private class KeepAliveServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new LineBasedFrameDecoder(2048)); //检测读写操作的空闲时间 ch.pipeline().addLast(new IdleStateHandler(0, WRITE_WAIT_SECONDS, 0)); ch.pipeline().addLast(new DataDecoder()); ch.pipeline().addLast(new DataEncoder()); //设置心跳处理器 ch.pipeline().addLast(new Heartbeat()); &#125; &#125; 心跳包处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private class Heartbeat extends SimpleChannelInboundHandler&lt;String&gt; &#123; JSONObject data; /** * 每一次收到消息时触发。 * @param ctx * @param msg * @throws Exception */ @Override protected void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception &#123; if (msg == null) &#123; return; &#125; data = new JSONObject(msg); if (!data.has(\"code\")) &#123; return; &#125; // 失败计数器清零 unRecPongTimes = 0; //处理从服务端接收到的消息 TODO &#125; //如果在指定的时间内容没有write事件，就会触发该方法 public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if (evt instanceof IdleStateEvent) &#123; IdleStateEvent event = (IdleStateEvent) evt; if (event.state() == IdleState.READER_IDLE) &#123; Logger.i(\"读超时)\"); &#125; else if (event.state() == IdleState.WRITER_IDLE) &#123; if (unRecPongTimes &lt; MAX_UN_REC_PONG_TIMES) &#123; //发送下一个心跳包，检测服务端是否还存活 ctx.channel().writeAndFlush(\"&#123;code:'ping'&#125;\"); unRecPongTimes++; &#125; else &#123; ctx.channel().close(); &#125; &#125; else if (event.state() == IdleState.ALL_IDLE) &#123; /*总超时*/ Logger.i(\"总超时)\"); &#125; &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; Logger.i(\"错误原因：\" + cause.getMessage()); if (data != null) &#123; &#125; ctx.channel().close(); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); &#125; /** * 连接断开 * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; ctx.close(); /* * 重连 */ if (!isStop) &#123; connServer(); &#125; Logger.i(\"客户端失效\"); &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android开发小技巧速查整理","date":"2016-10-12T00:48:26.000Z","path":"2016/10/12/应用开发小技巧速查/","text":"Activity.startActivities() 常用于在应用程序中间启动其他的Activity。 TextUtils.isEmpty() 用于检测是否为空。 Html.fromHtml() 用于生成一个Html,参数可以是一个字符串 TextView.setError() 验证用户输入,输入错误时可以设置错误提示。 Build.VERSION_CODES 这个标明了当前的版本号,点进去可以看到各个版本的不同特性。 Log.getStackTraceString() 日志类工具 LayoutInflater.from() 用于Inflate一个layout,参数是layout的id ViewConfiguration.getScaledTouchSlop() 这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动. PhoneNumberUtils.convertKeypadLettersToDigits 将字母转换为数字,类似于T9输入法, Context.getCacheDir() 获取缓存数据文件夹的路径 argbEvaluator.evaluate(fraction,startValue,endValue); 一个在两种色彩中，通过偏移量计算出另一个色彩的类。 用于处理颜色的渐变 ContextThemeWrapper 运行的时候修改主题。 Space 用来分隔不同的控件，其中形成一个空白的区域。在初始化的时候会跳过Draw这个过程。 ValueAnimator.reverse() 顺畅的取消动画效果 DateUtils.formatDateTime() 用来进行区域格式化工作，输出格式化和本地化的时间或者日期。 TypedValue.applyDimension() 对sp dp 和 px 之间进行单位转换 AlarmManager.setInexactRepeating 设置非准确闹钟。 在一些指定的时间点启动我们的服务进行处理事件。 当使用setInexactRepeating()时，系统可以在同一时间触发多个应用的闹钟，从而有效的减少设备的唤醒次数。 Formatter.formatFileSize() 一个区域化的文件大小格式化工具。把大小转换为MB，G，KB之类的字符串。 ActionBar.hide() 隐藏和显示ActionBar Linkify.addLinks() 在Text上添加链接 StaticLayout 绘制文本的时候指定绘制区域的宽度 Activity.onBackPressed() 管理back键的方法,在Activity中重写该方法可以用来处理back键的事件 GestureDetector 用来监听手势事件，比如点击，长按，慢滑动，快滑动 DrawFilter 可以暂时修改所使用的画笔，可以禁用/启用抗锯齿,或改变画的颜色。 ActivityManager.getMemoryClass() 获取机器剩余内存 ViewStub 在程序运行过程中动态的根据当前条件来决定是否显示某个控件或布局 ViewStub对象是一个看不见的，零大小的视图，并在程序运行时根据需要进行动态加载。只有ViewStub对象被设置为可见，或是调用了ViewStub.inflate()方法时，ViewStub对象所指向的布局才会被实例化，并加载到指向的父布局中。 SystemClock.sleep() 忽略中断异常的sleep操作 DisplayMetrics.density 获取设备像素密度 Pair.create() 构建类和构造器的方法。 UrlQuerySanitizer 一个用来处理url链接的工具类,可以很方便的获取url中的query参数 Fragment.setArguments 在初始化Fragment时向Fragment传参的一个很方便的接口，在Fragment中使用getArguments()来接收。 DialogFragment.setShowsDialog () 用于在Activity的内容之上展示一个模态的对话框。 有着和Fragment基本一致的声明周期。 FragmentManager.enableDebugLogging () 在需要观察 Fragment 状态的时候会有帮助。 LocalBroadcastManager 只能用于应用内通信，安全性更好，同时拥有更高的运行效率。 PhoneNumberUtils.formatNumber () PhoneNumverUtils提供了一系列方法用来格式化电话号码 Application.registerActivityLifecycleCallback(callback) 给Activity设置生命周期回调，可以监听到Activity的Created、Destory和Paused等。 versionNameSuffix 在Gradle脚本中使用该标签可以修改在Manifest中定义的VersionName -nodp 把一些不能被拉伸的图片放在 drawable-nodpi 中，此图片将不会被放大，以原大小显示。 Activity.recreate() 强制一个Activity重新创建自己一个新实例的方法，调用该方法目标Activity会重新走一遍自己的生命周期 PackageManager.checkSignatures () 检查两个apk安装包的签名是否一样，一样的话返回值&gt;0否则返回值&lt;0 Activity.isChangingConfigurations () 通常在onStop()函数中通过该函数来判断当前的Activity是否正在改变Configuration，从而来决定该Activity中引用的一些资源该如何处理， SearchRecentSuggestionsProvider 通常用与写入历史和读取搜索记录 ViewTreeObserver 可以注册监听正在屏幕上显示的视图树中任何视图状态的变化，可以用来视图初始化完成后获取某个控件的尺寸。 DatabaseUtils 一个包含各种数据库操作的使用工具类。 android:weightSum (LinearLayout) 可以用来定义总的 weight 数量。 android:duplicateParentState (View) 和父组件保持同样的状态。 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）。 需注意这两个属性只是传递点击状态而不会执行点击事件。 android:clipChildren (ViewGroup) 是否限制子View在其范围内 设置这个属性后子控件就可以在父控件的范围之外进行绘制了 android:fillViewport (ScrollView) 解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。 android:tileMode (BitmapDrawable) 用来设置Bitmap显示方式，有平铺、重复等。 android:enterFadeDuration/android:exitFadeDuration (Drawables) 为selector设置渐变效果 android:scaleType (ImageView) 设置ImageView 中图片的显示方式 Merge 优化UI结构，删除多余层级。 当你使用include标签添加布局文件时，系统会忽略merge节点并且直接添加它的子节点。 AtomicFile 保证文件的写入完成，并在写入之后删除备份文件。原子性 ViewDragHelper 它定义了一组有用的操作和状态追踪，允许用户在父ViewGroup中拖动并且重新定位子View ThumbnailUtil 帮助创建缩略图，包括视频缩略图 Context.getExternalFilesDir() getCacheDir()：获取/data/data/application package/cache目录 getFilesDir()：获取/data/data/application package/files目录 Context.getExternalFilesDir()：获取 SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据 Context.getExternalCacheDir()：获取SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据 ​ SparseArray SparseArray是Android为类型的HashMap专门写的类，目的是为了提供效率，其核心算法是半分查找法。 比 HashMap 节省内存，大概节省 35%左右的内存。 PackageManager.setComponentEnabledSetting() 使用这个方法可以开启和禁用四大组件。比如关掉一个当前不用的广播接收器。 SQLiteDatabase.yieldIfContendedSafely() 暂时停止一个数据库事务 这个方法表示我现在执行我的多次数据库操作，如果碰到其他的数据库操作，我先让别的操作完 再执行我的操作。 Environment.getExternalStoragePublicDirectory() 获取外部存储卡的公共目录 View.generateViewId() 动态生成控件的ID。 ActivityManager.clearApplicationUserData() 一键清理你的app产生的用户数据 API 19以上可以通过反射调用，需要应用具有android.permission.CLEAR_APP_USER_DATA权限 Context.createConfigurationContext() 自定义你的配置环境信息。 ActivityOptions 方便的定义两个Activity切换的动画。 ViewParent.requestDisallowInterceptTouchEvent() 使父控件不拦截当前的Touch事件 Fragment . setUserVisibleHint() 重写Fragment中的该方法，实现 fragment 对用户可见时才加载资源（延迟加载）。 该方法优先于oncreat()方法被调用 View.hasOverlappingRendering 告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程。 原理：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。 AutoScrollHelper 用于控件边缘触发自动滚动。 实现场景:歌词自动滚动 TouchSlop 最小的滑动距离， VelocityTracker 速度跟踪,跟踪触摸屏事件的速率 AlphabetIndexer 字母索引辅助类,实现对链表类型的数据进行快速索引。 ArrayMap 内部由两个数组维护的Array。 比 HashMap 更高的内存效率，但比 HashMap 慢，不适合有大量数据的场景。 ArrayMap相对于SparseArray，特点就是key值类型不受限 采用二分法查找 参考：Android Tips Round-Up 知乎问题：Android开发中，有哪些让你觉得相见恨晚的方法、类或接口？ #推荐阅读：awesome-android-tips 项目","tags":[{"name":"Tips","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"}]},{"title":"Hello World","date":"2016-10-11T10:30:37.000Z","path":"2016/10/11/hello-world/","text":"迷雾之中，顾自前行。","tags":[]}]